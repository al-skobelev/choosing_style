<!doctype html>
<html>
<head>
<meta charset='UTF-8'><meta name='viewport' content='width=device-width initial-scale=1'>
<title>choosing_style_en</title><style type='text/css'>html {overflow-x: initial !important;}:root { --bg-color: #ffffff; --text-color: #333333; --select-text-bg-color: #B5D6FC; --select-text-font-color: auto; --monospace: "Lucida Console",Consolas,"Courier",monospace; --title-bar-height: 20px; }
.mac-os-11 { --title-bar-height: 28px; }
html { font-size: 14px; background-color: var(--bg-color); color: var(--text-color); font-family: "Helvetica Neue", Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; }
body { margin: 0px; padding: 0px; height: auto; bottom: 0px; top: 0px; left: 0px; right: 0px; font-size: 1rem; line-height: 1.42857143; overflow-x: hidden; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; tab-size: 4; background-position: inherit inherit; background-repeat: inherit inherit; }
iframe { margin: auto; }
a.url { word-break: break-all; }
a:active, a:hover { outline: 0px; }
.in-text-selection, ::selection { text-shadow: none; background: var(--select-text-bg-color); color: var(--select-text-font-color); }
#write { margin: 0px auto; height: auto; width: inherit; word-break: normal; word-wrap: break-word; position: relative; white-space: normal; overflow-x: visible; padding-top: 36px; }
#write.first-line-indent p { text-indent: 2em; }
#write.first-line-indent li p, #write.first-line-indent p * { text-indent: 0px; }
#write.first-line-indent li { margin-left: 2em; }
.for-image #write { padding-left: 8px; padding-right: 8px; }
body.typora-export { padding-left: 30px; padding-right: 30px; }
.typora-export .footnote-line, .typora-export li, .typora-export p { white-space: pre-wrap; }
.typora-export .task-list-item input { pointer-events: none; }
@media screen and (max-width: 500px) { 
  body.typora-export { padding-left: 0px; padding-right: 0px; }
  #write { padding-left: 20px; padding-right: 20px; }
  .CodeMirror-sizer { margin-left: 0px !important; }
  .CodeMirror-gutters { display: none !important; }
}
#write li > figure:last-child { margin-bottom: 0.5rem; }
#write ol, #write ul { position: relative; }
img { max-width: 100%; vertical-align: middle; }
button, input, select, textarea { color: inherit; font-family: inherit; font-size: inherit; font-style: inherit; font-variant-caps: inherit; font-weight: inherit; font-stretch: inherit; line-height: inherit; }
input[type="checkbox"], input[type="radio"] { line-height: normal; padding: 0px; }
*, ::after, ::before { box-sizing: border-box; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p, #write pre { width: inherit; }
#write h1, #write h2, #write h3, #write h4, #write h5, #write h6, #write p { position: relative; }
p { line-height: inherit; }
h1, h2, h3, h4, h5, h6 { break-after: avoid-page; break-inside: avoid; orphans: 4; }
p { orphans: 4; }
h1 { font-size: 2rem; }
h2 { font-size: 1.8rem; }
h3 { font-size: 1.6rem; }
h4 { font-size: 1.4rem; }
h5 { font-size: 1.2rem; }
h6 { font-size: 1rem; }
.md-math-block, .md-rawblock, h1, h2, h3, h4, h5, h6, p { margin-top: 1rem; margin-bottom: 1rem; }
.hidden { display: none; }
.md-blockmeta { color: rgb(204, 204, 204); font-weight: 700; font-style: italic; }
a { cursor: pointer; }
sup.md-footnote { padding: 2px 4px; background-color: rgba(238, 238, 238, 0.701961); color: rgb(85, 85, 85); border-top-left-radius: 4px; border-top-right-radius: 4px; border-bottom-right-radius: 4px; border-bottom-left-radius: 4px; cursor: pointer; }
sup.md-footnote a, sup.md-footnote a:hover { color: inherit; text-transform: inherit; text-decoration: inherit; }
#write input[type="checkbox"] { cursor: pointer; width: inherit; height: inherit; }
figure { overflow-x: auto; margin: 1.2em 0px; max-width: calc(100% + 16px); padding: 0px; }
figure > table { margin: 0px; }
tr { break-inside: avoid; break-after: auto; }
thead { display: table-header-group; }
table { border-collapse: collapse; border-spacing: 0px; width: 100%; overflow: auto; break-inside: auto; text-align: left; }
table.md-table td { min-width: 32px; }
.CodeMirror-gutters { border-right-width: 0px; background-color: inherit; }
.CodeMirror-linenumber { }
.CodeMirror { text-align: left; }
.CodeMirror-placeholder { opacity: 0.3; }
.CodeMirror pre { padding: 0px 4px; }
.CodeMirror-lines { padding: 0px; }
div.hr:focus { cursor: none; }
#write pre { white-space: pre-wrap; }
#write.fences-no-line-wrapping pre { white-space: pre; }
#write pre.ty-contain-cm { white-space: normal; }
.CodeMirror-gutters { margin-right: 4px; }
.md-fences { font-size: 0.9rem; display: block; break-inside: avoid; text-align: left; overflow: visible; white-space: pre; background-image: inherit; background-size: inherit; background-attachment: inherit; background-origin: inherit; background-clip: inherit; background-color: inherit; position: relative !important; background-position: inherit inherit; background-repeat: inherit inherit; }
.md-diagram-panel { width: 100%; margin-top: 10px; text-align: center; padding-top: 0px; padding-bottom: 8px; overflow-x: auto; }
#write .md-fences.mock-cm { white-space: pre-wrap; }
.md-fences.md-fences-with-lineno { padding-left: 0px; }
#write.fences-no-line-wrapping .md-fences.mock-cm { white-space: pre; overflow-x: auto; }
.md-fences.mock-cm.md-fences-with-lineno { padding-left: 8px; }
.CodeMirror-line, twitterwidget { break-inside: avoid; }
.footnotes { opacity: 0.8; font-size: 0.9rem; margin-top: 1em; margin-bottom: 1em; }
.footnotes + .footnotes { margin-top: 0px; }
.md-reset { margin: 0px; padding: 0px; border: 0px; outline: 0px; vertical-align: top; text-decoration: none; text-shadow: none; float: none; position: static; width: auto; height: auto; white-space: nowrap; cursor: inherit; line-height: normal; font-weight: 400; text-align: left; box-sizing: content-box; direction: ltr; background-position: 0px 0px; background-repeat: initial initial; }
li div { padding-top: 0px; }
blockquote { margin: 1rem 0px; }
li .mathjax-block, li p { margin: 0.5rem 0px; }
li blockquote { margin: 1rem 0px; }
li { margin: 0px; position: relative; }
blockquote > :last-child { margin-bottom: 0px; }
blockquote > :first-child, li > :first-child { margin-top: 0px; }
.footnotes-area { color: rgb(136, 136, 136); margin-top: 0.714rem; padding-bottom: 0.143rem; white-space: normal; }
#write .footnote-line { white-space: pre-wrap; }
@media print { 
  body, html { border: 1px solid transparent; height: 99%; break-after: avoid-page; break-before: avoid-page; font-variant-ligatures: no-common-ligatures; }
  #write { margin-top: 0px; padding-top: 0px; border-color: transparent !important; }
  .typora-export * { -webkit-print-color-adjust: exact; }
  .typora-export #write { break-after: avoid-page; }
  .typora-export #write::after { height: 0px; }
  .is-mac table { break-inside: avoid; }
}
.footnote-line { margin-top: 0.714em; font-size: 0.7em; }
a img, img a { cursor: pointer; }
pre.md-meta-block { font-size: 0.8rem; min-height: 0.8rem; white-space: pre-wrap; background-color: rgb(204, 204, 204); display: block; overflow-x: hidden; background-position: initial initial; background-repeat: initial initial; }
p > .md-image:only-child:not(.md-img-error) img, p > img:only-child { display: block; margin: auto; }
#write.first-line-indent p > .md-image:only-child:not(.md-img-error) img { left: -2em; position: relative; }
p > .md-image:only-child { display: inline-block; width: 100%; }
#write .MathJax_Display { margin: 0.8em 0px 0px; }
.md-math-block { width: 100%; }
.md-math-block:not(:empty)::after { display: none; }
.MathJax_ref { fill: currentcolor; }
[contenteditable="true"]:active, [contenteditable="true"]:focus, [contenteditable="false"]:active, [contenteditable="false"]:focus { outline: 0px; box-shadow: none; }
.md-task-list-item { position: relative; list-style-type: none; }
.task-list-item.md-task-list-item { padding-left: 0px; }
.md-task-list-item > input { position: absolute; top: 0px; left: 0px; margin-left: -1.2em; margin-top: calc(1em - 10px); border: none; }
.math { font-size: 1rem; }
.md-toc { min-height: 3.58rem; position: relative; font-size: 0.9rem; border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom-right-radius: 10px; border-bottom-left-radius: 10px; }
.md-toc-content { position: relative; margin-left: 0px; }
.md-toc-content::after, .md-toc::after { display: none; }
.md-toc-item { display: block; color: rgb(65, 131, 196); }
.md-toc-item a { text-decoration: none; }
.md-toc-inner:hover { text-decoration: underline; }
.md-toc-inner { display: inline-block; cursor: pointer; }
.md-toc-h1 .md-toc-inner { margin-left: 0px; font-weight: 700; }
.md-toc-h2 .md-toc-inner { margin-left: 2em; }
.md-toc-h3 .md-toc-inner { margin-left: 4em; }
.md-toc-h4 .md-toc-inner { margin-left: 6em; }
.md-toc-h5 .md-toc-inner { margin-left: 8em; }
.md-toc-h6 .md-toc-inner { margin-left: 10em; }
@media screen and (max-width: 48em) { 
  .md-toc-h3 .md-toc-inner { margin-left: 3.5em; }
  .md-toc-h4 .md-toc-inner { margin-left: 5em; }
  .md-toc-h5 .md-toc-inner { margin-left: 6.5em; }
  .md-toc-h6 .md-toc-inner { margin-left: 8em; }
}
a.md-toc-inner { font-size: inherit; font-style: inherit; font-weight: inherit; line-height: inherit; }
.footnote-line a:not(.reversefootnote) { color: inherit; }
.md-attr { display: none; }
.md-fn-count::after { content: "."; }
code, pre, samp, tt { font-family: var(--monospace); }
kbd { margin: 0px 0.1em; padding: 0.1em 0.6em; font-size: 0.8em; color: rgb(36, 39, 41); background-color: rgb(255, 255, 255); border: 1px solid rgb(173, 179, 185); border-top-left-radius: 3px; border-top-right-radius: 3px; border-bottom-right-radius: 3px; border-bottom-left-radius: 3px; box-shadow: rgba(12, 13, 14, 0.2) 0px 1px 0px, rgb(255, 255, 255) 0px 0px 0px 2px inset; white-space: nowrap; vertical-align: middle; background-position: initial initial; background-repeat: initial initial; }
.md-comment { color: rgb(162, 127, 3); opacity: 0.8; font-family: var(--monospace); }
code { text-align: left; }
a.md-print-anchor { white-space: pre !important; border: none !important; display: inline-block !important; position: absolute !important; width: 1px !important; right: 0px !important; outline: 0px !important; text-shadow: initial !important; background-position: 0px 0px !important; background-repeat: initial initial !important; }
.md-inline-math .MathJax_SVG .noError { display: none !important; }
.html-for-mac .inline-math-svg .MathJax_SVG { vertical-align: 0.2px; }
.md-math-block .MathJax_SVG_Display { text-align: center; margin: 0px; position: relative; text-indent: 0px; max-width: none; max-height: none; min-height: 0px; min-width: 100%; width: auto; overflow-y: hidden; display: block !important; }
.MathJax_SVG_Display, .md-inline-math .MathJax_SVG_Display { width: auto; margin: inherit; display: inline-block !important; }
.MathJax_SVG .MJX-monospace { font-family: var(--monospace); }
.MathJax_SVG .MJX-sans-serif { font-family: sans-serif; }
.MathJax_SVG { display: inline; font-style: normal; font-weight: 400; line-height: normal; zoom: 90%; text-indent: 0px; text-align: left; text-transform: none; letter-spacing: normal; word-spacing: normal; word-wrap: normal; white-space: nowrap; float: none; direction: ltr; max-width: none; max-height: none; min-width: 0px; min-height: 0px; border: 0px; padding: 0px; margin: 0px; }
.MathJax_SVG * { transition: none; }
.MathJax_SVG_Display svg { vertical-align: middle !important; margin-bottom: 0px !important; margin-top: 0px !important; }
.os-windows.monocolor-emoji .md-emoji { font-family: "Segoe UI Symbol", sans-serif; }
.md-diagram-panel > svg { max-width: 100%; }
[lang="flow"] svg, [lang="mermaid"] svg { max-width: 100%; height: auto; }
[lang="mermaid"] .node text { font-size: 1rem; }
table tr th { border-bottom-width: 0px; }
video { max-width: 100%; display: block; margin: 0px auto; }
iframe { max-width: 100%; width: 100%; border: none; }
.highlight td, .highlight tr { border: 0px; }
mark { background-color: rgb(255, 255, 0); color: rgb(0, 0, 0); background-position: initial initial; background-repeat: initial initial; }
.md-html-inline .md-plain, .md-html-inline strong, mark .md-inline-math, mark strong { color: inherit; }
mark .md-meta { color: rgb(0, 0, 0); opacity: 0.3 !important; }
@media print { 
  .typora-export h1, .typora-export h2, .typora-export h3, .typora-export h4, .typora-export h5, .typora-export h6 { break-inside: avoid; }
}
.md-diagram-panel .messageText { stroke: none !important; }
.md-diagram-panel .start-state { fill: var(--node-fill); }
.md-diagram-panel .edgeLabel rect { opacity: 1 !important; }
.md-require-zoom-fix foreignObject { font-size: var(--mermaid-font-zoom); }


html {
	font-size: 19px;
}

html, body {
	margin: auto;
	background: #fefefe;
}
body {
	font-family: "Vollkorn", Palatino, Times;
	color: #333;
	line-height: 1.4;
	text-align: justify;
}

#write {
	max-width: 960px;
	margin: 0 auto;
	margin-bottom: 2em;
	line-height: 1.53;
	padding-top: 40px;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 1100px;
	}
}

@media print {
	html {
		font-size: 13px;
	}
}

/* Typography
-------------------------------------------------------- */

#write>h1:first-child,
h1 {
	margin-top: 1.6em;
	font-weight: normal;
}

h1 {
	font-size:3em;
}

h2 {
	margin-top:2em;
	font-weight: normal;
}

h3 {
	font-weight: normal;
	font-style: italic;
	margin-top: 3em;
}

h4 {
	font-weight: normal;
	font-style: italic;
	margin-top: 1.8em;
}

h1, 
h2, 
h3, 
h4{
	text-align: center;
}

h2:after{
	border-bottom: 1px solid #2f2f2f;
    content: '';
    width: 100px;
    display: block;
    margin: 0 auto;
    height: 1px;
}

h1+h2, h2+h3 {
	margin-top: 0.83em;
}

p,
.mathjax-block {
	margin-top: 0;
	-webkit-hypens: auto;
	-moz-hypens: auto;
	hyphens: auto;
}
ul {
	list-style: square;
	padding-left: 1.2em;
}
ol {
	padding-left: 1.2em;
}
blockquote {
	margin-left: 1em;
	padding-left: 1em;
	border-left: 1px solid #ddd;
}
code,
pre {
	font-family: "Consolas", "Menlo", "Monaco", monospace, serif;
	font-size: .9em;
	background: white;
}
.md-fences{
	margin-left: 1em;
	padding-left: 1em;
	border: 1px solid #ddd;
	padding-bottom: 8px;
	padding-top: 6px;
	margin-bottom: 1.5em;
}

a {
	color: #2484c1;
	text-decoration: none;
}
a:hover {
	text-decoration: underline;
}
a img {
	border: none;
}
h1 a,
h1 a:hover {
	color: #333;
	text-decoration: none;
}
hr {
	color: #ddd;
	height: 1px;
	margin: 2em 0;
	border-top: solid 1px #ddd;
	border-bottom: none;
	border-left: 0;
	border-right: 0;
}
.ty-table-edit {
	background: #ededed;
    padding-top: 4px;
}
table {
	margin-bottom: 1.333333rem
}
table th,
table td {
	padding: 8px;
	line-height: 1.333333rem;
	vertical-align: top;
	border-top: 1px solid #ddd
}
table th {
	font-weight: bold
}
table thead th {
	vertical-align: bottom
}
table caption+thead tr:first-child th,
table caption+thead tr:first-child td,
table colgroup+thead tr:first-child th,
table colgroup+thead tr:first-child td,
table thead:first-child tr:first-child th,
table thead:first-child tr:first-child td {
	border-top: 0
}
table tbody+tbody {
	border-top: 2px solid #ddd
}

.task-list{
	padding:0;
}

.md-task-list-item {
	padding-left: 1.6rem;
}

.md-task-list-item > input:before {
	content: '\221A';
	display: inline-block;
	width: 1.33333333rem;
  	height: 1.6rem;
	vertical-align: middle;
	text-align: center;
	color: #ddd;
	background-color: #fefefe;
}

.md-task-list-item > input:checked:before,
.md-task-list-item > input[checked]:before{
	color: inherit;
}
.md-tag {
	color: inherit;
	font: inherit;
}
#write pre.md-meta-block {
	min-height: 35px;
	padding: 0.5em 1em;
}
#write pre.md-meta-block {
	white-space: pre;
	background: #f8f8f8;
	border: 0px;
	color: #999;
	
	width: 100vw;
	max-width: calc(100% + 60px);
	margin-left: -30px;
	border-left: 30px #f8f8f8 solid;
	border-right: 30px #f8f8f8 solid;

	margin-bottom: 2em;
	margin-top: -1.3333333333333rem;
	padding-top: 26px;
	padding-bottom: 10px;
	line-height: 1.8em;
	font-size: 0.9em;
	font-size: 0.76em;
	padding-left: 0;
}
.md-img-error.md-image>.md-meta{
	vertical-align: bottom;
}
#write>h5.md-focus:before {
	top: 2px;
}

.md-toc {
	margin-top: 40px;
}

.md-toc-content {
	padding-bottom: 20px;
}

.outline-expander:before {
	color: inherit;
	font-size: 14px;
	top: auto;
	content: "\f0da";
	font-family: FontAwesome;
}

.outline-expander:hover:before,
.outline-item-open>.outline-item>.outline-expander:before {
  	content: "\f0d7";
}

/** source code mode */
#typora-source {
	font-family: Courier, monospace;
    color: #6A6A6A;
}

.html-for-mac #typora-sidebar {
    -webkit-box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
    box-shadow: 0 6px 12px rgba(0, 0, 0, .175);
}

.cm-s-typora-default .cm-header, 
.cm-s-typora-default .cm-property,
.CodeMirror.cm-s-typora-default div.CodeMirror-cursor {
	color: #428bca;
}

.cm-s-typora-default .cm-atom, .cm-s-typora-default .cm-number {
	color: #777777;
}

.typora-node .file-list-item-parent-loc, 
.typora-node .file-list-item-time, 
.typora-node .file-list-item-summary {
	font-family: arial, sans-serif;
}

.md-task-list-item>input {
    margin-left: -1.3em;
    margin-top: calc(1rem - 12px);
}

.md-mathjax-midline {
	background: #fafafa;
}

.md-fences .code-tooltip {
	bottom: -2em !important;
}

.dropdown-menu .divider {
	border-color: #e5e5e5;
}
/* #write { */
/* 	max-width: 35rem; */
/* } */

/* @media only screen and (min-width: 1400px) { */
/* 	#write { */
/* 		max-width: 35rem; */
/* 	} */
/* } */

#write {
	max-width: 35rem;
}

@media only screen and (min-width: 1400px) {
	#write {
		max-width: 35rem;
	}
}
 :root {--mermaid-font-zoom:1em ;} 
</style>
</head>
<body class='typora-export'>
<div id='write'  class=''><!-- <img src="eyecode-v2.jpg" style="zoom:75%" /> --><h1><a name="cognitive-code-style" class="md-header-anchor"></a><span>Cognitive Code Style</span></h1><h1><a name="how-to-optimize-program-readability" class="md-header-anchor"></a><span>How to Optimize Program Readability</span></h1><p>&nbsp;</p><p><em><span>At a coarse level, it’s clear that some forms of layout are better than others.</span></em>
<em><span>— Steve McConnell, Code Complete.</span></em></p><p>&nbsp;</p><h2><a name="contents" class="md-header-anchor"></a><span>Contents</span></h2><ul><li><p><a href="#introduction"><span>Introduction</span></a></p></li><li><p><a href="#features-of-human-vision"><span>Features of Human Vision</span></a></p><ul><li><a href="#field-of-view"><span>Field of View</span></a></li><li><a href="#ambient-and-focal-vision"><span>Ambient and Focal Vision</span></a></li><li><a href="#the-laws-of-perceptual-organization"><span>The Laws of Perceptual Organization</span></a></li><li><a href="#asymmetry-of-the-visual-field"><span>Asymmetry of the Visual Field</span></a></li></ul></li><li><p><a href="#how-we-read-texts"><span>How We Read Texts</span></a></p></li><li><p><a href="#program-comprehension"><span>Program Comprehension</span></a></p><ul><li><p><a href="#cognitive-models-of-program-comprehension"><span>Cognitive Models of Program Comprehension</span></a></p><ul><li><a href="#concepts-and-terminology"><span>Concepts and terminology</span></a></li><li><a href="#top-down-model"><span>Top-Down Model</span></a></li><li><a href="#bottom-up-model"><span>Bottom-Up Model</span></a></li><li><a href="#opportunistic-and-systematic-strategies"><span>Opportunistic and Systematic Strategies</span></a></li></ul></li><li><p><a href="#specifics-of-reading-program-texts"><span>Specifics of Reading Program Texts</span></a></p></li><li><p><a href="#role-of-identifiers"><span>Role of Identifiers</span></a></p></li></ul></li><li><p><a href="#basic-principles-of-formatting"><span>Basic Principles of Formatting</span></a></p><ul><li><a href="#building-the-visual-structure"><span>Building the Visual Structure</span></a></li><li><a href="#line-length"><span>Line Length</span></a></li><li><a href="#names"><span>Names</span></a></li><li><a href="#spaces"><span>Spaces</span></a></li><li><a href="#arranging-curly-braces"><span>Arranging Curly Braces</span></a></li></ul></li><li><p><a href="#conclusion"><span>Conclusion</span></a></p></li></ul><h2><a name="introduction" class="md-header-anchor"></a><span>Introduction</span></h2><p><em><span>At the risk of giving my fellow scientists good reason for displeasure, I am applying the principles in which I believe with a somewhat reckless one-sidedness, … partly because in certain cases it is useful to state a point of view with crude simplicity and leave the refinements to the ensuing play of thrust and counterthrust.</span></em>
<em><span>— Rudolph Arnheim, Art and Visual Perception</span></em></p><p><em><span>First, we want to establish the idea that a computer language is not just a way of getting a computer to perform operations but rather that it is a novel formal medium for expressing ideas about methodology. Thus, programs must be written for people to read, and only incidentally for machines to execute.</span></em>
<em><span>— Harold Abelson and Gerald Jay Sussman, Structure and Interpretation of Computer Programs.</span></em></p><p><em><span>Indeed, the ratio of time spent reading vs. writing is well over 10:1… Because this ratio is so high, we want the reading of code to be easy, even if it makes the writing harder.</span></em>
<em><span>— Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship.</span></em></p><p>&nbsp;</p><p><span>Probably no one needs to prove that the </span><em><span>readability</span></em><span> of the program text is one of the decisive factors that determine the success of its maintenance and development.</span></p><p><span>Usually, when evaluating the text of a program in terms of its </span><em><span>ease of perception</span></em><span>, the term </span><em><span>readability</span></em><span> is used. Strictly speaking, they are not exactly the same thing, because, as will be shown later, the process of perceiving a program is more than just reading. However, since we are talking about text, and the term </span><em><span>readability</span></em><span> is fairly well-established, I will also use it in that sense.</span></p><p><span>In order to maintain readability of the code, during program development it is common to agree on some common set of formatting rules (style) for the source code. The very existence of a set of such rules can have a positive effect on its readability and quality, since, firstly, it forms certain habits among programmers regarding the language constructions that they expect to see in the program text, and, secondly, it forces them to be more attentive to what they have written (unless, of course, the formatting of the code is completely transferred to the auto-formatting tools).</span></p><p><span>However, individual rules are often questionable because the criteria for their selection are unclear and they often contradict similar rules in other similar styles.</span></p><p><span>The rules provide specific details for how the code is formatted to maintain readability, but there is no explanation of how the rules help achieve it. Without understanding this, the solution to the engineering problem of forming a readable (i.e optimal in the sense of perception) program text is replaced by thoughtless adherence to formal and often arbitrarily chosen rules, which usually change when moving from project to project, from language to language. As a result, a false idea is formed that the what the rules say is not so important, and the choice of one or another style is just a matter of taste and habit.</span></p><p><span>Indeed, our habits largely determine how comfortable we feel in a given situation and, in particular, how we perceive a particular formatting style. But the feeling of comfort due to habit cannot be a measure of how objectively good this style is. It is obvious that the habit of a certain style can only mean that we simply stopped noticing the specific features of this style, which in fact can be counterproductive in the sense of forming </span><em><span>objectively readable</span></em><span> code.</span></p><p><span>When I speak of </span><em><span>objective readability</span></em><span>, I mean that the full readability of a text consists of a subjective component, caused by developed habits and skills, which we talked about above, and an objective one. This second component is determined by the capabilities and limitations of the mechanisms of perception and processing of visual information common to all people in the normal mental and physical state.</span></p><p><span>Thus, the subjective component is associated with some private habits that can be changed, and the objective – with the general psychophysical features of a human&#39;s vision, which we do not assume is possible to change. Therefore, when talking about optimizing the text of a program, it makes sense to talk only about the objective component of readability, and therefore further in this article the term </span><em><span>readability</span></em><span> will always refer to this component of it.</span></p><p><span>Let&#39;s take a closer look at what we know about the mechanisms of human perception of visual information, reading plain texts, and reading and perceiving program texts.</span></p><p>&nbsp;</p><h2><a name="features-of-human-vision¹fn-1" class="md-header-anchor"></a><span>Features of Human Vision</span><a href='#fn-1'><span>¹</span></a></h2><h3><a name="field-of-view" class="md-header-anchor"></a><span>Field of View</span></h3><p><span>The human </span><a href='https://www.ncbi.nlm.nih.gov/books/NBK220/'><span>field of view</span></a><span> is relatively large: 50° superiorly, 60° inferiorly, 90° temporally (towards an ear) and 50° nasally. Situated in the temporal hemifield is the normal blind spot approximately 12 to 17 degrees from fixation and 1.5 degrees below the horizontal meridian. Within this field, visual acuity and color perception are unevenly distributed: visual acuity of the order of 1&#39; is achieved in the area of ​​</span><em><span>fovea</span></em><span>, which forms ~2° of central (</span><em><span>foveal</span></em><span>) vision, but it is not so good in the </span><em><span>parafoveal</span></em><span> area (which covers 5° in both directions from the fixation point) and even worse at the periphery.</span><a href='#fn-5'><span>⁵</span></a></p><p><span>Likewise, the ability to distinguish colors decreases from the center to the edge, and this change is different for different color components. We can say that moving from the center of the human retina to the periphery, we seem to find ourselves in earlier stages of evolution, moving from the most highly organized structures to the primitive eye, which distinguishes only the simple movement of shadows.</span></p><p><strong><span>Figure 1. Field of view of the human right eye. Orange spot - the place of projection of the fundus blind spot.(</span><a href='https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B5_%D0%B7%D1%80%D0%B5%D0%BD%D0%B8%D1%8F#/media/%D0%A4%D0%B0%D0%B9%D0%BB:Goldmann_visual_field_record_sheet.svg'><span>orig.</span></a><span>)</span></strong></p><p><img src="1920px-Goldmann_visual_field_record_sheet.svg.png" style="zoom:30%;" /></p><!-- <img src="https://habrastorage.org/webt/7v/mo/qz/7vmoqzost4u5nzaeluqofvn3we4.png" style="zoom:20%;" /> --><h3><a name="ambient-and-focal-vision" class="md-header-anchor"></a><span>Ambient and Focal Vision</span></h3><p><span>In modern neuropsychology, there is a concept of </span><em><span>ambiant</span></em><span> (from the French </span><strong><span>ambiant</span></strong><span> ‘surrounding’) and </span><em><span>focal</span></em><span> visual systems. While the first, evolutionarily more ancient, is responsible for dynamic spatial localization, the second deals with the identification of objects.</span></p><p><strong><span>Table. 1. Comparative features of focal and ambient systems</span></strong></p><figure><table><thead><tr><th><span>Visual System</span></th><th><span>Focal</span></th><th><span>Ambient</span></th></tr></thead><tbody><tr><td><span>Function</span></td><td><span>What</span></td><td><span>Where / How</span></td></tr><tr><td><span>Engagement in movement</span></td><td><span>Less</span></td><td><span>More</span></td></tr><tr><td><span>Awareness / Memory</span></td><td><span>More</span></td><td><span>Less or missing</span></td></tr><tr><td><span>Temporary properties</span></td><td><span>Slow</span></td><td><span>Fast</span></td></tr><tr><td><span>Light Sensitivity</span></td><td><span>High</span></td><td><span>Low</span></td></tr><tr><td><span>Spatial resolution</span></td><td><span>High</span></td><td><span>Low</span></td></tr></tbody></table></figure><p><span>The objects that represent the source of the necessary information are far unevenly distributed. They are usually localized in small areas of the visual field. With the help of ambient vision, a potentially interesting object or element of the object is detected, and with the help of focal vision aimed at the object, this information is perceived and analyzed in more detail. When faced with a new situation or with a new object, we, as a rule, first look &quot;wide field&quot; and only then concentrate our attention on details.</span></p><p><span>Examination of the environment and selection of objects for detailed processing is carried out using head and body movements, which are superimposed on a subtle pattern of eye movements. The most famous of their varieties are </span><em><span>saccades</span></em><span> — extremely fast (~ 500°/sec) jumps of a ballistic type, changing the position of the eyes in orbit and making it possible to highlight fragments of the scene for subsequent </span><em><span>fixation</span></em><span>.</span></p><p><strong><span>Figure 2. Reproduction of Ilya Repin&#39;s painting and recording of the subject&#39;s eye movements.</span></strong><a href='#fn-2'><span>²</span></a></p><p><img src="Yarbus_ne_zhdaly.jpg" style="zoom:90%;" /></p><p><!-- <img src="https://habrastorage.org/webt/vi/-m/vw/vi-mvwhun4tp2e2h1sk-cuob0mu.jpeg" /> -->
<span>Studies of the relationship between ambient (global) and focal (local) visual processing began in the experiments of David Navon in 1977. He presented subjects with large letters consisting of small letters. Some of these compound stimuli were &quot;homogeneous&quot; – the global form and local elements were the same letter. Others were &quot;heterogeneous&quot; – the global and local letters were different (say, &quot;E&quot; and &quot;S&quot;). The subjects had to identify the global or local letter as quickly as possible.</span></p><p><strong><span>Figure 3. Homogeneous and heterogeneous super letters from David Navon&#39;s experiments.</span></strong></p><p><img src="Velichkovskiy_FF.png" /></p><!-- <img src="https://habrastorage.org/webt/yu/ha/z3/yuhaz3cdetforzujr9xsmssmyac.png" /> --><p><span>It turned out that when set to the global form, it is identified quickly and without any interference with matching or non-matching letters of the local level. When set to identify parts (i.e. small letters), the picture was different. First, the responses were slower. Second, in the case of heterogeneous stimuli, responses were further slowed down and become less accurate. Obviously, </span><em><span>when we set ourselves up for granularity, we cannot always ignore global information</span></em><span>.</span></p><p><span>Research on the relationship of global and local processing, tested with the Navona super letters, revealed a possible differential role for the posterior left and right hemispheres of the brain. In this case, the left hemisphere turned out to be more of a tuning regulator for details, and the right one for global outlines. The influence of emotions turned out to be extremely interesting: negative emotions, in contrast to positive ones, strengthened the attitude towards the perception of details.</span></p><h3><a name="the-laws-of-perceptual-organization" class="md-header-anchor"></a><span>The Laws of Perceptual Organization</span></h3><p><span>An interesting feature of our vision is the ability to perceive a group of objects as a whole. So in the image below we see a dog, and not just a chaotic set of spots:</span></p><p><strong><span>Figure 5. Dalmatian.</span></strong></p><p><img src="dog.jpg" /></p><p><!-- <img src="https://habrastorage.org/webt/nm/8m/-7/nm8m-7vtm8sly2bjy1_vmilhnu0.jpeg" /> -->
<span>And here we clearly see a square and a circle:</span></p><p><strong><span>Figure 6. Shapes from points.</span><a href='#fn-4'><span>⁴</span></a></strong></p><p><img src="Arnheim_1.png" referrerpolicy="no-referrer"></p><p><!-- <img src="https://habrastorage.org/webt/lo/sp/oh/lospoh3jfddv6dkgtotqvuepjv0.png" /> -->
<span>There are many explanations for these illusions. In terms of cognitive bionomy, the need to see shapes, edges, and movements (as well as faces) was dictated by the need for survival. Thus, even in the absence of real lines or shapes, our sensory-cognitive system used partial information to create these shapes in an attempt to make the seemingly chaotic world intelligible.</span></p><p><span>Take a look at the picture below and you will see how, over time, the orientation of the triangles changes from one direction to another, a third.</span></p><p><strong><span>Figure 7. Triangles changing orientation.</span><a href='#fn-3'><span>³</span></a></strong></p><p><img src="triangles.png"/></p><p><!-- <img src="https://habrastorage.org/webt/0a/og/y_/0aogy_yxzq8bnzxf-unhccm8d-w.png" /> -->
<span>Thus, we can say that </span><em><span>in the absence of a clearly expressed dominant structure, our brain is constantly spending resources in search of such a structure</span></em><span>.</span></p><p><span>Gestalt psychologists were the first to study this phenomenon of perceptual organization. They formulated the basic law of visual perception, according to which </span><em><span>any stimulating model is perceived in such a way that the resulting structure will be, as far as the given conditions allow, the simplest</span></em><span>. Therefore, we perceive the square exactly as it is depicted on the left, and not in some other way:</span></p><p><strong><span>Figure 8. Options for organizing points into a shape.</span><a href='#fn-4'><span>⁴</span></a></strong></p><p><img src="Arnheim_2.png" referrerpolicy="no-referrer"></p><!-- <img src="https://habrastorage.org/webt/hm/j3/0m/hmj30mmpg6_b_cu3rk0bgrdds1w.png" /> --><p><span>Gestalt psychologists have also formulated 6 principles of perceptual organization. In accordance with these principles, </span><em><span>objects that</span></em></p><ul><li><em><span>located close to each other (&quot;the law of proximity&quot;),</span></em></li><li><em><span>have similar brightness and color characteristics (&quot;similarities&quot;),</span></em></li><li><em><span>restrict a small, closed (&quot;closed&quot;)</span></em></li><li><em><span>and a symmetric area (&quot;symmetry&quot;),</span></em></li><li><em><span>naturally continue each other (&quot;good continuation&quot;),</span></em></li><li><em><span>move at approximately the same speed in one direction (&quot;common destiny&quot;),</span></em></li></ul><p><em><span>will sooner be perceived as a whole, or a figure, and not as disparate elements of the environment, or background</span></em><span>.</span></p><p><strong><span>Figure 9. Examples of similarity in proximity, color and size.</span><a href='#fn-4'><span>⁴</span></a></strong></p><p><img src="Arnheim_3.png" /></p><!-- <img src="https://habrastorage.org/webt/0-/6r/qu/0-6rqup1wemlrmemrzbf5vpui8u.png" /> --><p><span>In the case of competition of several factors of perceptual organization, the priority is usually given to the factor of </span><em><span>proximity</span></em><span>, and then the factor of similarity in </span><em><span>color</span></em><span>, </span><em><span>orientation</span></em><span> or </span><em><span>size</span></em><span>.</span></p><p><span>Taking these principles into account turns out to be important in the case of perceptual search or perception, because, </span><em><span>if information is organized in accordance with these principles, the solution of the problem posed requires less effort due to the fact that the perceptual field is subjected to grouping, and a smaller proportion of common resources are successively allocated to the formed groups of elements</span></em><span>. The distribution of resources within each group is approximately equal.</span></p><p><span>The tasks of visual search are usually complicated by the addition of irrelevant objects (</span><em><span>distractors</span></em><span>). However, </span><em><span>in the case when distractors form visually compact groups, allowing them to be ignored as a whole, their addition, on the contrary, can greatly facilitate the search</span></em><span>.</span></p><h3><a name="asymmetry-of-the-visual-field" class="md-header-anchor"></a><span>Asymmetry of the Visual Field</span></h3><p><span>Similar to the asymmetry between the left and right hand, there is some asymmetry in how we perceive the left and right visual fields. Perhaps this is also due to asymmetries in the left and right hemispheres of the brain, which are responsible for processing sensory information from the right and left visual fields, respectively.</span></p><p><span>Thus, in the scenic arts it is known that there is a difference between the left and right halves of the stage: when the curtain rises in the theater, the audience is inclined to look to its left first and to identify with the characters appearing on that side. Therefore, among the so-called stage areas the left side (from the audience&#39;s viewpoint) is considered stronger. In a group of actors, the one farthest left dominates the scene. The audience identifies with him and sees the others, from his position, as opponents. Likewise the observer experiences a picture as though he were facing its left side. He subjectively identifies with the left, and whatever appears there assumes greatest importance.</span><a href='#fn-4'><span>⁴</span></a><span> Thus, in addition to the natural balance point in the center of the visual scene, an additional center is formed in its left part.</span></p><p>&nbsp;</p><h2><a name="how-we-read-texts⁵fn-5" class="md-header-anchor"></a><span>How We Read Texts</span><a href='#fn-5'><span>⁵</span></a></h2><p><span>When we read, our eyes incessantly make rapid mechanical (i.e., not controlled by consciousness) movements, </span><em><span>saccades</span></em><span>. On average, their length is 7-9 letter spaces. At this time we do not receive new information. </span></p><p><span>The primary function of a saccade is to bring a new region of text into foveal vision (~2° central field of view) for detailed analysis, because reading on the basis of only parafoveal or peripheral information is difficult to impossible.</span></p><p><span>Between saccades, our eyes remain relatively motionless for the duration of </span><em><span>fixations</span></em><span> (about 200 – 300 ms). During this period, we recognize the visible part of the text and plan where to make the next jump.</span></p><p><strong><span>Figure 10. Typical pattern of eye movements while reading.</span><a href='#fn-1'><span>¹</span></a></strong></p><p><img src="Velichkovskiy_reading.png" style="zoom:80%;" /></p><!-- <img src="https://habrastorage.org/webt/kv/rt/ln/kvrtlnwdjge8ouyfzzaulxu7dyo.jpeg" /> --><p><strong><span>Table 1. Approximate Mean Fixation Duration and Saccade Length in Reading, Visual Search, Scene Perception, Music Reading, and Typing</span></strong></p><figure><table><thead><tr><th><span>Task</span></th><th><span>Mean fixation duration (ms)</span></th><th><span>Mean saccade size (degrees)</span></th></tr></thead><tbody><tr><td><span>Silent reading</span></td><td><span>225</span></td><td><span>2 (about 8 letters)</span></td></tr><tr><td><span>Oral reading</span></td><td><span>275</span></td><td><span>1.5 (about 6 letters)</span></td></tr><tr><td><span>Visual search</span></td><td><span>275</span></td><td><span>3</span></td></tr><tr><td><span>Scene perception</span></td><td><span>330</span></td><td><span>4</span></td></tr><tr><td><span>Music reading</span></td><td><span>375</span></td><td><span>1</span></td></tr><tr><td><span>Typing</span></td><td><span>400</span></td><td><span>1 (about 4 letters)</span></td></tr></tbody></table></figure><p><span>Letter spaces are the appropriate metric to use, because the number of letters traversed by saccades is relatively invariant when the same text is read at different distances, even though the letter spaces subtend different visual angles.</span><a href='#fn-7'><span>⁷</span></a></p><p><span>Whereas a majority of the words in a text are fixated during reading, many words are skipped so that foveal processing of each word is not necessary.</span></p><p><span>About 10-15% of the time, readers move their gaze back in the text (</span><em><span>regressions</span></em><span>) in order to re-read what has already been read. As the difficulty of the text increases, the duration of fixations and the frequency of regressions increase, and the length of saccades decreases.</span></p><p><span>During fixation, we get information from the </span><em><span>perceptual span</span></em><span>. The size of this area is relatively small, in the case of alphabetic orthographies (for example, in European languages) it starts from the beginning of the fixed word, but no more than 3-4 letter spaces to the left of the fixation point, and extends to about 14-15 letter spaces to the right of this point (in total 17-19 spaces).</span></p><p><span>The </span><em><span>identification span</span></em><span>, that is, the scope required to identify a fixed word, is less than the perceptual span and, as a rule, does not exceed 7-8 letter spaces to the right of the fixation (in total, about 10-12 spaces).</span></p><p><span>The availability of the first three letters of a word during the previous fixation leads to a decrease in the fixation time on that word. Some researches have also shown that the letter information to the right of the fixation can be used to determine whether the next word should be skipped.</span></p><p><span>Most of the research suggests that boundary information (conveyed by the spaces between words) is the major determinant used in deciding where to move to next; saccade length is influenced by both the length of the fixated word and the word to the right of fixation.</span></p><p><span>Most readers are slowed down (on average by about 30%) by the absence of space information, and experiments demonstrated that </span><em><span>both word identification processes and eye guidance are disrupted by the lack of space information</span></em><span>.</span></p><p><span>It was found that, when space information is provided for readers of Thai (who are not used to reading with spaces between words), they read more effectively than normal. There are reports that the reading of long German compound words is facilitated by the insertion of spaces, even though this format is ungrammatical and never encountered in normal reading.</span></p><p><em><span>Thus, it appears safe to conclude that space information is used for guiding the eyes in reading.</span></em></p><p><span>Word-length information may be used not only in determining where to fixate next but also in how parafoveal information is used. That is, enough parafoveal letter information may be extracted from short words so that they can be identified and skipped, whereas partial-word information (the first three letters) extracted from longer parafoveal words may rarely allow full identification of them but facilitate subsequent foveal processing.</span></p><p><span>Word-length information also plays a clear role in where in the word a reader fixates. Although there is variability in where the eyes land on a word, readers tend to make their first fixation on a word about halfway between the beginning and the middle of a word.</span></p><p><span>Word-length information helps to guide the eye toward </span><em><span>the preferred viewing location</span></em><span>, i.e. a location between the beginning and the middle of the word. When the space indicating the location of word n+1 was visible in the parafovea, the first fixation on that word was closer to the preferred viewing location than when the parafoveal preview did not contain that space information.</span></p><p><span>Although the average landing position in a word lies between the beginning and middle of a word, this position varies as a function of the distance from the prior launch site. For example, if the distance to a target word is large (8-10 letter spaces), the landing position is shifted to the left. Likewise, if the distance is small (2-3 letter spaces), the landing position is shifted to the right.</span></p><p><span>The location of the first fixation is between the beginning and the middle of a word for words that are 4-10 letters long (either for the first fixation in a word or when only a single fixation is made). However, with longer words, the effect breaks down, and readers tend to fixate near the beginning of the word and then make a second fixation toward the end of the word.</span></p><p><span>Informational density (or morphological structure) of the word influences how long the fixations are on each half of the word. For example, it was found that if the word was predictable from the first 6 letters (the words were typically about 12 letters), readers generally made a fixation in the first half of the word and then moved their eyes to the next word; if they made a second fixation on the word it tended to be quite short. However, if the word could only be identified by knowing what the ending was, readers typically made a short fixation at the beginning followed by a longer fixation on the end of the word.</span></p><p><span>With respect to visual search task it was found that when the target was at a small </span><em><span>eccentricity</span></em><span>, it was located accurately with a single saccade; when the target was more peripheral, wrongly directed initial saccades were common (up to 40% of the time). Also </span><em><span>in a complex search tasks the eyes is initially directed to the center of the global display and then to the centers of recursively smaller groups of objects until the target was acquired</span></em><span>.</span></p><h2><a name="program-comprehension" class="md-header-anchor"></a><span>Program Comprehension</span></h2><p><span>Programs differ from natural language texts in two important ways. First, programs are lexically and syntactically different from natural language texts. Lexically, they are composed from a limited vocabulary, with some words used as programming language keywords, and others used more freely as identifiers to name program constructs like variables and methods. Syntactically, programs are laid out and organized differently than natural language texts. They feature greater use of formally defined structures and multiple forms of indented layout (both horizontal and vertical). The second difference is semantic. Natural language text is typically understood in two concurrent phases: text (how it is written down) and domain (what it means). Source code comprehension however needs a third dimension of comprehension: execution. Thus, in order to understand a program’s goals, programmers must be able to trace source code execution to discover its operational semantics.</span><a href='#fn-6'><span>⁶</span></a></p><h3><a name="cognitive-models-of-program-comprehension⁸fn-8" class="md-header-anchor"></a><span>Cognitive Models of Program Comprehension</span><a href='#fn-8'><span>⁸</span></a></h3><h4><a name="concepts-and-terminology" class="md-header-anchor"></a><span>Concepts and terminology</span></h4><p><span>A </span><em><span>mental model</span></em><span> describes a developer&#39;s mental representation of the program to be understood whereas a </span><em><span>cognitive model</span></em><span> describes the cognitive processes and temporary information structures in the programmer’s head that are used to form the mental model. </span></p><p><em><span>Programming plans</span></em><span> are generic fragments of code that represent typical scenarios in programming. For example, a sorting program will contain a loop which compares two numbers in each iteration.</span></p><p><em><span>Delocalized plans</span></em><span> – programming plans realized by lines scattered in different parts of the program. Delocalized plans complicate program comprehension.</span><a href='#fn-10'><span>¹⁰</span></a></p><p><em><span>Beacons</span></em><span> are recognizable, familiar features in the code that act as cues to the presence of certain structures.</span></p><p><em><span>Rules of programming</span></em><span> discourse capture the conventions of programming, such as coding standards and algorithm implementations. </span>
<!-- These rules form certain expectations in the mind of the programmer. --></p><h4><a name="top-down-model" class="md-header-anchor"></a><span>Top-Down Model</span></h4><p><span>In this model, it is assumed that programmers understand a completed program in a top-down manner where the comprehension process is one of reconstructing knowledge about the domain of the program and mapping this knowledge to the source code. The process starts with a hypothesis about the general nature of the program. This initial hypothesis is then refined in a hierarchical fashion by forming subsidiary hypotheses. Subsidiary hypotheses are refined and evaluated in a depth-first manner. The verification (or rejection) of hypotheses depends heavily on the absence or presence of beacons.</span></p><p><span>Top-down understanding is used when the code or type of code is familiar; expert programmers use beacons, programming plans and rules of programming discourse to decompose goals and plans into lower-level plans.</span></p><h4><a name="bottom-up-model" class="md-header-anchor"></a><span>Bottom-Up Model</span></h4><p><span>The bottom-up theory of program comprehension assumes that programmers first read code statements and then mentally chunk or group these statements into higher level abstractions. These abstractions (chunks) are aggregated further until a high-level understanding of the program is attained.</span></p><h4><a name="opportunistic-and-systematic-strategies" class="md-header-anchor"></a><span>Opportunistic and Systematic Strategies</span></h4><p><span>With these strategies, programmers either systematically read the code in detail, tracing through the control-flow and data-flow abstractions in the program to gain a global understanding of the program, or that they take an as-needed approach, focusing only on the code relating to a particular task at hand.</span></p><p><span>Subjects using a systematic strategy acquire both static knowledge (information about the structure of the program) and causal knowledge (interactions between components in the program when it is executed). This enabled them to form a mental model of the program. Those using the as-needed approach only acquire static knowledge resulting in a weaker mental model of how the program worked. More errors occurre since the programmers fail to recognize causal interactions between components in the program.</span></p><h3><a name="specifics-of-reading-program-texts" class="md-header-anchor"></a><span>Specifics of Reading Program Texts</span></h3><p><span>A comparative study of the linearity of program reading by novices and experts</span><a href='#fn-6'><span>⁶</span></a><span> showed that novices read source code less linearly than natural language text. Moreover, experts read code less linearly than novices. These findings indicate that there are specific differences between reading natural language and source code, and suggest that non-linear reading skills increase with expertise.</span></p><p><span>Below, as an example, giving an idea of ​​the difference in reading ordinary texts and program texts, the results of one experiment</span><a href='#fn-11'><span>¹¹</span></a><span> on the analysis of the eye movements of programmers while reading the code are presented.</span></p><p><strong><span>Figure 11. Traces of eye movement of two expert programmers when reading the same code.</span></strong>
<img src="code_reading_patterns.png"/>
<!-- <img src="https://habrastorage.org/webt/pq/1j/wr/pq1jwrfci64zg0fwszuwcu3o2f8.jpeg" /> --></p><p><span>The programmers were given different tasks: the first (left figure) was expected to receive an answer, what is the return value of </span><code>rect2.area()</code><span>, the second was told that he would be given a multiple choice question about the algorithmic idea.</span></p><p><span>As we can see, these scanpaths are quite different, however, the differences in gaze appear deeper than this difference in what they were expecting to be asked, and suggest that different readers read code in markedly different manners.</span></p><p><span>According to the authors, reader 1’s gaze might politely be described as erratic. Considered in real time, it flashes wildly about the code, generally spending very little time on any one point. Viewed over time, there is a clear pattern of returning to certain focal points, points that are pertinent to the question that the reader was told to expect; but the gaze fixations are so brief as to leave the analyst wondering whether it is possible to gain any comprehension of the code.</span></p><p><span>Reader 2, by contrast, appears to read the code slowly and methodically. There are elements of linear scanning, and gaze remains far longer on areas of interest.</span></p><p><span>Indeed, in the illustration on the left, we observe a rather chaotic trajectory with a large number of long vertical saccades, and on the right, there are mainly horizontal saccades, most of which can be associated with reading the text in a general sense.</span></p><p><span>We can say that in the first case, we see the dominance of fast ambient vision, characterized by long saccades and short fixations, and in the second, slow focal vision.</span></p><p><span>The authors describe the following basic types of eye movements that make up more complex code reading strategies:</span></p><p><strong><span>Table 3. Basic types of eye movements when reading code.</span></strong></p><figure><table><thead><tr><th><span>Type</span></th><th><span>Description</span></th></tr></thead><tbody><tr><td><span>Flicking</span></td><td><span>The gaze moves back and forth between two related items, such as the formal and actual parameter lists of a method call.</span></td></tr><tr><td><span>JumpControl</span></td><td><span>Subject jumps to the next line according to execution order.</span></td></tr><tr><td><span>JustPassingThrough</span></td><td><span>Fixations are on a blank spot and clearly just stop on the way to some place else.</span></td></tr><tr><td><span>LinearHorizontal</span></td><td><span>Subject reads a whole line either from from left to right or right to left, all elements in rather equally dis- tributed time.</span></td></tr><tr><td><span>LinearVertical</span></td><td><span>Subject follows text line by line, for at least three lines, no matter of program flow, no distinction between signature and body.</span></td></tr><tr><td><span>RetraceDeclaration</span></td><td><span>Often-recurring jumps between places where variable is used and where it had been declared. Form of Flicking.</span></td></tr><tr><td><span>RetraceReference</span></td><td><span>Often-recurring jumps between places where variable is used and where it had been recently referred to. Form of Flicking.</span></td></tr><tr><td><span>Scan</span></td><td><span>Subject first reads all lines of the code from top to bottom briefly. A preliminary reading of the whole program, which occurs during the first 30% of the review time.</span></td></tr><tr><td><span>Signatures</span></td><td><span>Subject looks at all signatures first, before looking into method/constructor body.</span></td></tr><tr><td><span>Thrashing</span></td><td><span>The gaze moves rapidly and wildly in a sequence that appears to make no particular sense.</span></td></tr><tr><td><span>Word(Pattern)Matching</span></td><td><span>Simple visual pattern matching.</span></td></tr></tbody></table></figure><h3><a name="role-of-identifiers⁹fn-9" class="md-header-anchor"></a><span>Role of Identifiers</span><a href='#fn-9'><span>⁹</span></a></h3><p><span>The comprehension of identifier names in programs is at the core of program understanding. Identifier names are often key beacons to program plans that support higher-level mental models of understanding. Identifiers make up approximately 70% of source code. If a certain identifier naming style significantly increases the speed of code comprehension, this could significantly impact overall program understanding.</span></p><p><span>In general, using actual words rather than abbreviations lead to better comprehension. Identifiers that violate certain guidelines have lower code quality (more bug patterns) than ones that don’t. Longer names reduce correctness and take longer to recall.</span></p><p><span>In an eye-tracking study analyzing the effect of identifier style (camel-case and underscore) on accuracy, time, and visual effort, with respect to the task of recognizing a correct identifier in a phrase, it was shown that, although, no difference was found between identifier styles with respect to accuracy, results indicate a significant improvement in time and lower visual effort with the underscore style.</span></p><p><strong><span>Figure 12. Part of two gaze plots for the correct underscore (left) and camel-cased (right) versions of the 3-word code identifier</span><a href='#fn-9'><span>⁹</span></a></strong></p><p><img src="underscore_vs_camelcase.png" /></p><!-- <img src="https://habrastorage.org/webt/2-/dz/vt/2-dzvtxei7st1fmgikp2ww6p4zw.jpeg" /> --><h2><a name="basic-principles-of-formatting" class="md-header-anchor"></a><span>Basic Principles of Formatting</span></h2><h3><a name="building-the-visual-structure" class="md-header-anchor"></a><span>Building the Visual Structure</span></h3><p><span>A priori, we know that a program has a certain logical and syntactic structure, and we expect that the structure of its visual representation will reflect them accordingly.</span></p><p><span>As mentioned above, our brain is in constant search for some optimal interpretation of the visual scene, which allows us to explain it in the simplest way. Therefore, it can be asserted that the more clearly the visual structure is formed, and the more accurately it reflects the structure of the program, the less mental effort we will spend on the perception of this program.</span></p><p><span>When we visually perceive the program, we get the first impression and evaluate the visual structure of the text mainly due to ambient vision, which has low acuity and color perception, deteriorating from the center to the edge. Fast ambient vision helps us to highlight points of interest in the code for further analysis and reading using slow focal vision. This means that, speaking about the general visual structure of the program text, we must move from the domain of ​​focal vision, that is, from letters and symbols, to the domain of ​​ambient vision, that is, to  ​​spots and the relationships between them.</span></p><p><span>The sequence of the main structural elements in the program is developed in the vertical direction, so when evaluating the overall visual structure of the program, when covering it with a &quot;wide view&quot;, vertical eye movement prevails, accompanied by small horizontal deviations. The horizontal movement of the gaze associated mainly with the transition to focal vision and reading directly allows us to get the details of these elements.</span></p><p><span>Therefore, for a correct assessment of the overall structure of the program, it is important to form the correct visual structure in the vertical direction.</span></p><p><span>For example, in a function definition, we need to visually separate the function declaration, including its name, return type, parameter list, and function body. Inside the body of the function, it is necessary to separate the initialization code of the initial variables, the body of the main algorithm, the formation and return of the result. In turn, within the initialization code, we need to separate the scope of types, variable names, and values ​​assigned to them.</span></p><p><span>Consider the following example:</span></p><p><img src="cpp1.png" style="width:720px;" /></p><p><span>To analyze the visual structure, let&#39;s make a test similar to the </span><em><span>squint test</span></em><span> used by the UI designers. Alan Cooper describes this test in his book as follows</span><a href='#fn-14'><span>¹⁴</span></a><span>:</span></p><blockquote><p><span>Close one eye and squint at the screen with the other eye to see which elements pop out, which are fuzzy, and which seem to be grouped. Changing your perspective can often uncover previously undetected issues in layout and composition.</span></p></blockquote><p><span>In fact, by squinting, we are trying to gauge how we perceive an image through ambient vision. Instead of squinting, you can try to look at the code with a defocused gaze and somewhat away from the fragment of interest.</span></p><p><img src="cpp1_blur.png" style="width:720px;" /></p><p><span>The visual structure of this code contains only three large areas, which obviously does not reflect the program structure correctly.</span></p><p><span>Stacking vertically allows you to correct this defect:</span></p><p><img src="cpp2.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/iq/i3/7i/iqi37ixwxuqufyuwxusni3cnneu.png" /> --><p><span>The squint test of it:</span></p><p><img src="cpp2_blur.png" style="width:720px;" /></p><p>&nbsp;</p><!-- <img src="https://habrastorage.org/webt/6e/fc/py/6efcpyacl2rcz7idcoiw29thjkk.jpeg" /> --><p><span>Regions of text can be composed of lines of the same structure. In this case, it makes sense to group the same line elements, thereby emphasizing their horizontal structure. This grouping will highlight the common and make the differences more visible.</span></p><p><span>This way we structure the text both vertically and horizontally. In the first case, we perform these splits by adding blank lines. In the second, we use indentation and alignment.</span></p><p><span>Indents are used to form a visual representation of the hierarchy in the program structure between elements on different lines.</span></p><p><span>Let&#39;s take a look at the following code:</span></p><p><img src="indent1.png"  style="width:777px;"/></p><!-- <img src="https://habrastorage.org/webt/xb/jn/kr/xbjnkre3zaikfrmbo1pctjlcnha.png"  style="zoom:50%;"/> --><p><span>The list of arguments is presented as a column and is indented relative to the first line. Is this indentation sufficient to correctly display the logical structure of the program? Obviously not.</span></p><p><span>The proximity rule binds the argument list to the variable name more strongly than to the function name, even though syntax highlighting creates a color similarity. But what happens if the highlighting algorithm changes? Here&#39;s what the same code looked like on gitlab:</span></p><p><img src="indent3.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/qh/gv/7i/qhgv7iklbl_6jujgqm6kluodd60.png"  style="zoom:50%;"/> --><p><span>In this case, syntax highlighting made things worse, since the color similarity rule now also strengthens the association of arguments with a variable name. The function name has nothing to do with it.</span></p><p><span>When scanning text, such an arrangement provokes eye movement from the resulting variable </span><code>success</code><span> directly to the column of the list of arguments and only then regression to the function name.</span></p><p><em><span>Syntax highlighting can greatly facilitate the perception of the program. However, in the case of an incorrect visual structure, the effect of it can be completely opposite. Considering also that since the programmer has no control over the syntax highlighting, it should not be taken into account when assessing whether its particular visual representation is readable and correctly reflects the structure of the program.</span></em></p><p><span>To correctly display the logical structure of this code in its visual representation, it is necessary that the list of arguments is indented not relative to the beginning of the line, but relative to the beginning of the function name:</span></p><p><img src="indent4.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/nz/z9/6l/nzz96lrnme0kfnbe0fhcm8ktgvq.png"  style="zoom:50%;"/> --><p><span>In this case, it is clearly seen that the function argument list is syntactically part of the function call expression and is logically a set of parameters that is accepted by the function.</span></p><p><span>Let&#39;s do a squint test. We will also disable syntax highlighting in order to exclude grouping by the color similarity factor, which we do not control:</span></p><p><img src="indent4_blurred.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/pd/hd/_n/pdhd_n8bny50x3nqwltsihpvwik.jpeg"  style="zoom:50%;"/> --><p><span>You can see that the function name and argument list form a tightly coupled scope. However, when using two spaces for indentation, the subordination of the argument list relative to the function name does not seem expressive enough. Using four spaces helps to solve this problem:</span></p><p><img src="indent4-4_blurred.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/ot/kj/u_/otkju_th20tr1orgivwrq8ju0qo.jpeg"  style="zoom:50%;"/> --><p><span>One more problem remains: the list of arguments looks like one unstructured spot, despite the fact that there are two types of elements, the labels of the arguments and their values. This list has a certain structure, and in order to visually highlight this structure, we should use alignment. But before that, let&#39;s digress from this example for a while and look at various ways to format an argument list as label:value.</span></p><p><strong><span>One line formatting</span></strong></p><p><img src="code1.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/xm/os/gy/xmosgy6pigronododp5uljr5oly.png"  style="zoom:50%;"/> --><p><span>In this version, the visual structure does not reflect the structure of the expression, so the search is difficult. This option is only intended to be read carefully.</span></p><p><span>Due to the large length of the line, the rest of it, which did not fit on the first line, was placed on the second one. In this case, the editor made an indent showing the subordination of this line relative to the previous one. However, elsewhere (for example, in the comparison pane on gitlab), the second line will most likely start at the beginning and the visual structure of the piece of code will be broken.</span></p><p><strong><span>Label:value pairs alignment</span></strong></p><p><img src="code2.png"  style="width:720px;"/></p><p><!-- <img src="https://habrastorage.org/webt/ir/gp/zb/irgpzbpqbvhdnsuzbrdnxhemwum.png"  style="zoom:50%;"/> -->
<span>This option looks better in the sense that the method name and the argument list are clearly separated from each other. It is already a little easier to search in the argument list, since each pair is on a separate line and the labels are left aligned.</span></p><p><span>However, distinguishing between labels and values ​​is difficult because there is no clear border between label and value areas for the entire list. In addition, since the text is perceived as anchored on the left and free on the right, visually this code appears as a large mass (the area of ​​the argument list) suspended from a thin and long arm. The bulk of the code turns out to be strongly shifted to the right, less important part of the space.</span></p><p><span>In this case, we can try to fix the last flaw by shifting the list of arguments to the left:</span></p><p><img src="code3.png"  style="width:720px;"/></p><p><!-- <img src="https://habrastorage.org/webt/gd/3y/us/gd3yuslr14dsmyu4f1m4tsy4ssk.png"  style="zoom:50%;"/> -->
<span>To better represent the internal structure of the argument list, it is necessary to form an explicit dividing line between the label and value areas. We have two options here.</span></p><p><strong><span>Option 1: labels and arguments are left aligned separately</span></strong></p><p><img src="code4.png"  style="width:720px;"/></p><p><!-- <img src="https://habrastorage.org/webt/qc/n8/zh/qcn8zhxgazbgclie1_0o0c3iv0c.png"  style="zoom:50%;"/> -->
<span>Of all the options proposed so far, this one most accurately conveys the logical structure of the code. It clearly distinguishes the areas of labels and values, identifying and finding individual elements within them is much easier. However, due to the large difference in the label lengths of the arguments, the bonds within pairs with short labels are weakened.</span></p><p><strong><span>Option 2: inner alignment</span></strong></p><p><img src="code5.png"  style="width:720px;"/></p><p><!-- <img src="https://habrastorage.org/webt/oe/zj/lj/oezjljl0bqs6rc0gryw6822r4e8.png"  style="zoom:50%;"/> -->
<span>Having all the advantages of the previous option, this option looks more natural for this example. In it, the argument labels look like a natural continuation of the method name, as it should be in this case. The code looks compact enough without the need to carry the argument list to the next line.</span></p><p><span>For the </span><code>reticulateSplines</code><span> example, the code in this styling would look like this:</span></p><p><img src="indent5.png"  style="width:720px;"/></p><p><!-- <img src="https://habrastorage.org/webt/q-/ff/ay/q-ffaynkxm45pkwpe4ivn0ef0b0.png"  style="zoom:50%;"/> -->
<span>Alignment is a powerful tool for optimizing the visual presentation of code by forming compact groups in a horizontal direction.</span></p><p><span>Let&#39;s analyze the following code:</span></p><p><img src="proto1.png"  style="width:724px;"/></p><!-- <img src="https://habrastorage.org/webt/fs/mg/k0/fsmgk0pgwcqzom18vxjrcqkgnpq.png"  style="zoom:50%;"/> --><p><span>Basically, every single protocol declaration looks reasonably readable. However, this cannot be said about the entire text: the general structure is inexpressive, there are no clearly expressed masses in it that could attract the eye. As a result, &quot;dazzles in the eyes&quot;, and there is a feeling of tiring monotony. To perceive this code, it can only be read sequentially and completely: </span><em><span>&quot;protocol DataBaseDependent ServiceDependent var dataBase DataBase get set, protocol LocalConfigDependent …&quot;</span></em></p><p><span>Let&#39;s reformat it so that each declaration spans one line and align it:</span></p><p><img src="proto3.png"  style="width:724px;"/></p><!-- <img src="https://habrastorage.org/webt/pt/uu/bv/ptuubvmnslk97jdapakeffafaa0.png"  style="zoom:50%;"/> --><p><span>Now clearly defined groups (grouping by &quot;proximity&quot;) have been formed in the horizontal direction, and the structure of each definition and the differences between them have been clearly revealed. The way this code is read is also different. After a quick initial familiarization with the structure and identifying common parts, further analysis simply ignores these common parts, and attention is focused only on the different parts. Thus, due to the more active use of ambient vision, the load on the focal vision is reduced and the amount of mental effort required to understand the program is reduced.</span></p><p><span>As mentioned above, there is some asymmetry in how we perceive the left and right sides of the visual scene. This asymmetry is even more natural in the perception of the program text: the text is rigidly anchored to the left margin, where indents set the level of hierarchy in the logical structure of the program. The right edge is free and does not have a hard limit. Reading from left to right and top to bottom determines that </span><em><span>everything new we expect to see top and left or center</span></em><span>.</span></p><p><span>Because of that, the following constructions cannot be called good in terms of readability:</span></p><p><img src="closure1.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/82/x3/y1/82x3y16luvwnxvimg_cdysisniq.png"  style="zoom:50%;"/> --><p><span>In such constructs, the new namespace begins at the end of the line, that is, in the least important area, where this beginning is not expected. It&#39;s more natural to place the beginning of this block of code where it should be — at the top left:</span></p><p><img src="closure2.png"  style="width:720px;"/></p><!-- <img src="https://habrastorage.org/webt/d3/2s/en/d32senybyy8wrbv9di8l_xy_tta.png"  style="zoom:50%;"/> --><h3><a name="line-length" class="md-header-anchor"></a><span>Line Length</span></h3><p><span>The absence of a hard constraint on the right does not mean that there is no constraint at all. Centuries of typography</span><a href='#fn-12'><span>¹²</span></a><span> and decades of </span><a href='http://webtypography.net/2.1.2'><span>web designers</span></a><span> experience agree that the optimal line length for comfortable reading is approximately 45-75 characters.</span></p><p><span>Despite the structural differences in program texts, it is difficult to imagine that these differences are so strong that they can make long lines difficult to read in ordinary text easy when we are reading a program. On the contrary, one might expect that programs, like scientific publications, require shorter lines than prose.</span><a href='#fn-15'><span>¹⁵</span></a></p><p><span>Apparently, following Steve McConnell</span><a href='#fn-13'><span>¹³</span></a><span>, some developers say that on their large monitors long lines fit perfectly, and their presence in the code is normal. This argument of &quot;large monitors&quot; does not hold water:</span></p><ul><li><span>A long line is difficult to capture with a &quot;wide eye&quot;.</span></li><li><span>The perception of the structure of expression is difficult due to the fact that this structure is smeared along the line and does not form clearly expressed compact visual areas.</span></li><li><span>Due to the implicit structure and the increase in eccentricity, the search is difficult.</span></li><li><span>Due to the increase in distance, transitions from the end of the line to the beginning of the next become more difficult, and accordingly reading slows down.</span></li><li><span>Increasing the distance to the monitor will reduce the angular dimensions of the line, but it will also reduce the size of the letters, and thus will not reduce the length of the saccade. Smaller letters are more difficult to recognize. Hence, reading will slow down.</span></li><li><span>Large monitors are not always available or program text may be displayed in a much smaller area. In this case, the line either does not fit in the scope and requires scrolling, or the line is split into several lines and this, as a rule, destroys the structure of the program in the entire scope.</span></li></ul><p><span>For a number of objective reasons, it is not always possible to avoid long lines (for example, due to the use of long identifiers that we cannot change). Also, in cases where we are not interested in the structure of the expression (for example, when outputting a debug message to the program log), the use of a long line may be even preferable to structuring a long expression by breaking it into several lines, since it makes this code less massive and so less meaningful for ambient vision.</span></p><p><span>In general, massive use of long lines, like long identifiers, is a sign of poor code readability.</span></p><h3><a name="names" class="md-header-anchor"></a><span>Names</span></h3><p><span>Names are critical to making your code readable. They occupy a large part of it and often act as beacons to identify characteristic structural parts of the program. The main requirements for names are their expressiveness and brevity. </span><em><span>The longer the name, the more difficult it is to read, remember and recall.</span></em><span> Long names usually lead to long lines, which also makes reading and search difficult. The requirement of expressiveness means that in the scope of the context of use, the name must allow to unambiguously determine the role of the program element it denotes.</span></p><p><span>The requirements for brevity and expressiveness can obviously conflict with each other, as expressiveness may require the use of longer, compound names. Therefore, it makes sense to make an estimate of the recommended name length.</span></p><p><span>Ideally, we want to recognize the name at a glance (on first fixation). This means that the first estimate of the optimal length can be set as the size of the identification area, that is, 10-12 characters.</span></p><p><span>A feature of program texts, as already mentioned above, is that the set of valid words in them is limited, so it is highly likely that even in the case of a longer name, we will be able to subsequently recognize it by the first part, so even with a length of more than 12 characters we only need one fixation. However, we want this name to fit into the size of the recognition area (17-19 characters) and leave some margin, so that our brain can optimally plan the next saccade. If we take 4 characters from the end of the recognition area, we get an estimate of 13-15 characters.</span></p><p><span>Admitting in rare cases two fixations with “guessing”, we get an estimate of 20-24 characters (13-15 from the previous estimate + 7-9 per saccade within a word).</span></p><p><span>Taking the means of the estimated ranges, we get the following table:</span></p><p><strong><span>Table 4. Estimates of the maximum name length.</span></strong></p><figure><table><thead><tr><th><span>Fixation count</span></th><th><span>Maximum name length</span></th></tr></thead><tbody><tr><td><span>1</span></td><td><span>11</span></td></tr><tr><td><span>1 (guessing the suffix)</span></td><td><span>14</span></td></tr><tr><td><span>2</span></td><td><span>22</span></td></tr></tbody></table></figure><p><span>These guidelines are reasonably consistent with the boundaries given in Steve McConnell&#39;s book</span><a href='#fn-14'><span>¹⁴</span></a><span>: 10-16 and 8-20. Now we can somehow explain them.</span></p><p><span>In practice, it is sometimes necessary to use names that are outside the suggested lengths. For example, when the name includes some standard naming of the group to which the given item belongs, as in </span><code>PreferencesViewController</code><span>. By having the meaningful, unique part of the name at the beginning, we can expect to recognize the unique part of the name on the first fixation, and at the same time, we do not need much effort to recognize the &quot;common continuation&quot;.</span></p><p><span>With rare exceptions, it doesn&#39;t make sense to use any abbreviated prefixes in the names that describe some common characteristics (for example, type) or to denoting classes that are part of your application. Prefixes mask the meaningful part of the name, in their presence the position of the first fixation on the word during reading shifts to the left from the optimal one, they require more mental effort for additional analysis of the identifier. In some cases, they can change the meaning of an identifier (is </span><code>kBytesPerSec</code><span> is &quot;kilobytes per second&quot; or the constant </span><code>BytesPerSec</code><span>?).</span></p><p><span>Decorating class and function names only makes sense if you are developing a library in a language that lacks the namespaces to limit their visibility. All entities defined within your application are at the top level of the namespace and generally do not need any prefixes to prevent name collisions.</span></p><h3><a name="spaces" class="md-header-anchor"></a><span>Spaces</span></h3><p><span>As mentioned above, using any other separator between words instead of a space makes reading difficult, because of the difficulties in determining the boundaries of a word, which in turn lead to difficulties in recognizing and planning the next saccade.</span></p><p><span>Therefore, it is recommended to separate identifiers in the program using spaces, even if formally such separation is not required. For example, it makes sense to separate the function name and the list of its parameters/arguments with a space:</span>
<img src="space1.png" style="width:720px;" />
<!-- <img src="https://habrastorage.org/webt/1r/iy/il/1riyil0pm_dpnf0h9jkivaqvspi.png"  style="zoom:50%;"/> --></p><p><span>There is no space on the first line, and the function name visually sticks to the first argument in the argument list. In addition to the difficulty in reading, we can also notice that the visual structure does not quite correctly reflect the logical structure of the program: the function call expression includes the function name and the argument list, the argument list includes the first and second arguments. In the first line, the function name is more strictly bound to the first argument than the arguments to each other.</span></p><p><span>One more example:</span></p><p><img src="space3_1.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/rs/dz/ku/rsdzkuirda_pdn22_ocsalvl8rg.png"  style="zoom:50%;"/> --><p><span>After splitting into two groups, adding spaces and alignment:</span></p><p><img src="space3_2.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/xv/ff/yr/xvffyrmbd0n3tn-ay-xxkdhsjqc.png"  style="zoom:50%;"/> --><p><span>In this case, the addition of spaces not only made it easier to read individual lines due to the explicit separation of identifiers within them, but (together with alignment) made it easier to compare them by forming compact visual groups horizontally. Trying to understand what this code does, you no longer have to read each line separately.</span></p><p><span>In the case when the total length of identifiers does not exceed the size of the recognition area, this requirement is not so critical, since the entire expression can be immediately captured with one glance:</span></p><p><img src="space2.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/qx/o-/al/qxo-alqr0-hwf2ycvpjo_wwh2dq.png"  style="zoom:50%;"/> --><h3><a name="arranging-curly-braces" class="md-header-anchor"></a><span>Arranging Curly Braces</span></h3><p><span>Today, languages ​​with C-like syntax are dominated by two main ways of placing curly braces: in the first, the open parenthesis is on a separate line with the same indentation as the beginning of the preceding syntax element associated with it, and in the second, the open parenthesis is located at the end of the line containing the ending of such an element.</span></p><p><span>In what follows, I will conventionally call these styles </span><em><span>Allman</span></em><span> and </span><em><span>One Truce Brace Style</span></em><span> (</span><em><span>1TBS</span></em><span>) by the names of the most popular styles that use the appropriate brace placement rules.</span></p><p><span>Placing the opening parenthesis at the beginning of a single line in the </span><em><span>Allman</span></em><span> style has the following advantages:</span></p><ul><li><span>The open brace is always located on the left side of the visual area, that is, in the area of greatest attention, and when scanning a code (in which vertical eye movements prevail), it always somehow falls into the area of focal vision. In the </span><em><span>1TBS</span></em><span> style, the open parentheses are often in the right region of the code and only fall into the peripheral vision, which makes them much more difficult to detect. In other words, what in the first case occurs naturally, in the second requires additional and special efforts.</span></li><li><span>Facilitated matching of opening and closing braces and, accordingly, defining the boundaries of the code block surrounded by them. Searching for a paired brace requires only vertical movement of the gaze, there is no text on its path from one brace to another, and the search proceeds in a known direction up to the first character.</span>
<span>Indeed, whenever we see a closing parenthesis in the text on a separate line, we know that the matching opening parenthesis is </span><em><span>higher</span></em><span>, which means that the main and natural direction of searching for it will be upward search.</span>
<span>When using </span><em><span>1TBS</span></em><span>, searching is generally more effortful due to the fact that it is carried out in a wide sector, with the view passing through the text that needs to be analyzed, and which often contains nested pairs of curly braces that visually compete with the target.</span></li><li><span>The parenthesis is located at the beginning of the line, exactly where we expect to see the beginning of anything, and naturally denotes the beginning of the block of code. In the </span><em><span>1TBS</span></em><span> style, because of its position at the end of a line, the open parenthesis often ceases to act as an explicit visual marker for the beginning of a block. Moreover, in some cases (for example, repeated </span><code>} else if</code><span> constructions), the closing brace of the previous block appears at the beginning of the line containing the construct preceding the new block, and thus visually connects to the beginning of this block. Thus, its formal and visual meanings cease to correspond to each other.</span></li><li><span>Placing parentheses on separate lines naturally adds vertical spaces between the syntactic construction before the opening bracket and the framed code block, which, in most cases, better reflects the structure of the entire construction.</span></li><li><span>The horizontal position of the opening brace in the style of </span><em><span>Allman</span></em><span> uniquely determines the nesting level to which it belongs. </span><em><span>1TBS</span></em><span> does not contain this information, since the location of the open brace is mainly determined only by the length of the line before it.</span></li></ul><p><span>The disadvantages of </span><em><span>1TBS</span></em><span> lead to the fact that the opening curly brace ceases to fully participate in the formation of the visual presentation of the code, the style provokes the programmer not to separate the code blocks inside the braces and their surrounding elements with empty lines, and as a result, the program text often looks like one poorly structured massive chunk:</span></p><p><img src="picture36.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/y1/kr/zq/y1krzqjyfs1tpw0wshh7kznwioy.png" style="zoom:50%;" /> --><p><span>The code in the example above demonstrates the main problems of the </span><em><span>1TBS</span></em><span> style mentioned, namely: the absence of a clearly expressed visual structure, the inversion of the role of the closing braces, the loss of the visual significance of the opening braces, which, at a cursory glance at the code, are only approximately guessed using peripheral vision and their exact location requires additional horizontal eye movements. And this is an example of relatively simple code, since in it the conditions of the </span><code>if</code><span> expression occupy only one line, and the open braces are on the same line as the </span><code>if</code><span> expression, and the code blocks inside the braces have a fairly simple linear structure and do not contain nested blocks.</span></p><p><span>Reformatting this code using the </span><em><span>Allman</span></em><span> style allows for a more acceptable result:</span></p><p><img src="picture37.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/jv/x-/pf/jvx-pfjfuqs01oiohffb9mjmltw.png" style="zoom:50%;" /> --><p><span>Despite the fact that in most cases </span><em><span>Allman</span></em><span> objectively outperforms </span><em><span>1TBS</span></em><span>, sometimes </span><em><span>1TBS</span></em><span> is preferable. As a rule, in the such cases the additional vertical space formed by placing braces on separate lines in the style of </span><em><span>Allman</span></em><span> leads to the fact that the whole structure becomes visually fragmented, loses its internal rhythm and ceases to be perceived as a single whole. And at the same time, when using </span><em><span>1TBS</span></em><span>, either the offset of the opening parenthesis is small and does not have a significant effect on the perception of the code, or its detection is not critical (for example, in the case of the </span><code>if</code><span> construction, when both the condition and the block of code occupy one line each).</span></p><p><span>So in the previous example, placing the last open brace at the end of the line looks quite natural, and the resulting empty space only adds a small accent, compensating for the small visual mass of the last block, consisting of only one line. When the brace is placed on a separate line, this space becomes too large, and this line looks torn off from the rest of the construction:</span></p><p><img src="picture38.png" style="width:720px;" /></p><!-- <img src="https://habrastorage.org/webt/qx/b5/qe/qxb5qetfvjaier48xmxjlzw1yr8.png" style="zoom:50%;" /> --><p><span>The question arises: in what cases is it permissible to use </span><em><span>1TBS</span></em><span>? The following restrictions can be suggested:</span></p><ul><li><span>The open parenthesis is on the same line as the beginning of the syntactic construct of which it is a part.</span></li><li><span>The parenthesis is not masked by a large mass of code directly adjacent to it (mostly from above).</span></li><li><span>It is located in the left area of ​​the text (area of ​​greatest attention).</span></li><li><span>The horizontal offset of the parenthesis should not be large, so that the parenthesis is in the recognition area (14-15 letter sizes).</span></li><li><span>A block bounded by braces does not contain nested blocks such that the braces bounding these nested blocks are located close to the opening brace of the main block and visually compete with it.</span></li></ul><p><span>Thus, the choice of the method for placing parentheses should be carried out in each specific case, and formal adherence to the &quot;strict&quot; placement rules sooner or later leads to an unsatisfactory result. The best option seems to be a combination of the </span><em><span>Allman</span></em><span> (as the main) and </span><em><span>1TBS</span></em><span> styles (as an auxiliary, used in rare cases).</span></p><h2><a name="conclusion" class="md-header-anchor"></a><span>Conclusion</span></h2><p><span>The formation of a readable, that is, easily comprehensible program text requires taking into account the specific features of human vision, such as ambient and focal vision, the mechanisms of reading text in general and the features of reading program texts in particular.</span></p><p><span>The main strategy for optimizing readability can be formulated as </span><em><span>making more efficient use of ambient vision and reducing the load on the focal one</span></em><span>.</span></p><p><span>The implementation of this strategy is achieved by forming the text in the form of a relatively compact horizontally &quot;image&quot; with a pronounced visual structure that correctly reflects the logical structure of the program. This image is formed by hierarchically grouping logically related program elements into compact visual areas by means of horizontal indentation,  blank lines and alignment. The ease of reading the program text is also ensured by the choice of identifiers that are optimal in terms of length and expressiveness and their explicit separation in the program text using spaces.</span></p><p><span>In his book on typography, Robert Bringhurst writes </span><a href='#fn-12'><span>¹²</span></a><span>:</span></p><blockquote><p><span>Headings, subheads, block quotations, footnotes, illustrations, captions and other intrusions into the text create syncopations and variations against the base rhythm of regularly leaded lines. These variations can and should add life to the page…</span></p></blockquote><blockquote><p><span>However empty or full it may be, the page must breathe, and in a book — that is, in a long text fit for the reader to live in — the page must breath in both directions.</span></p></blockquote><p><span>Similarly, we can say that the structure of the program, unfolding in the text from top to bottom, also has a certain rhythm and variations. The task of the programmer is to visualize this rhythm, to make it explicit in general and in detail.</span></p><hr /><p><a id="fn-1" ></a><span>¹) Величковский Б.М. Когнитивная наука. Основы психологии познания. Academia, Смысл, 2006</span></p><p><a id="fn-2" ></a><span>²) Yarbus A L. Eye Movements and Vision. New York: Plenum Press, 1967.</span></p><p><a id="fn-3" ></a><span>³) Robert L.Solso. Cognitive psychology. 6-th edition. Allyn &amp; Bacon, 2001.</span></p><p><a id="fn-4" ></a><span>⁴) Rudolph Arnheim. Art and Visual Perception.  University of California Press, 1974</span></p><p><a id="fn-5" ></a><span>⁵) </span><a href="https://www.semanticscholar.org/paper/Eye-movements-in-reading-and-information-20-years-Rayner/87c8a7be8d5e2e2209e766c3e28a3e8ee5babb64"><span>Eye Movements in Reading and Information Processing: 20 Years of Research. Keith Rayner – University of Massachusetts at Amherst</span></a></p><p><a id="fn-6" ></a><span>⁶) </span><a href="https://researchonline.gcu.ac.uk/files/24953094/ICPC2015_authors_version.pdf"><span>Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif</span></a></p><p><a id="fn-7" ></a><span>⁷) </span><a href="https://link.springer.com/article/10.3758/BF03206156"><span>Saccade size in reading depends upon character spaces and not visual angle. Robert E. Morrison, Keith Rayner, 1981</span></a></p><p><a id="fn-8" ></a><span>⁸) </span><a href="http://www.ptidej.net/courses/inf6306/fall10/slides/course8/Storey06-TheoriesMethodsToolsProgramComprehension.pdf"><span>Theories, tools and research methods in program comprehension: Past, Present and Future. Margaret-Anne Storey</span></a></p><p><a id="fn-9" ></a><span>⁹) </span><a href="http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf"><span>An Eye Tracking Study on camelCase and under</span><span>_</span><span>score Identifier Styles. Bonita Sharif and Jonathan I. Maletic – Department of Computer Science Kent State University</span></a></p><p><a id="fn-10" ></a><span>¹⁰) </span><a href="http://www.cs.kent.edu/~jmaletic/Prog-Comp/Papers/letovsky-1986-software.pdf"><span>S. Letovsky and E. Soloway, Delocalized plans and program comprehension, IEEE Software, pp. 41–49, 1986.</span></a></p><p><a id="fn-11" ></a><span>¹¹) </span><a href="http://emipws.org/wp-content/uploads/2015/02/emip2013_report.pdf"><span>Eye movements in programming education: analysing the expert’s gaze. Simon. University of Newcastle, Australia</span></a></p><p><a id="fn-12" ></a><span>¹²) Robert Bringhurst. Elements of Typographic Style. Hartley &amp; Marks, Publishers, 1996 </span></p><p><a id="fn-13" ></a><span>¹³) Steve McConnell. Code Complete: A Practical Handbook of Software Construction. Microsoft Press, 2004</span></p><p><a id="fn-14" ></a><span>¹⁴) Alan Cooper. About Face: The Essentials of Interaction Design, Fourth Edition. John Wiley &amp; Sons, Inc., 2014</span></p><p><a id="fn-15" ></a><span>¹⁵) </span><a href="https://www.sovsib.ru/docs/ost2912494.pdf"><span>ОСТ 29.124–94. Издания книжные для взрослых читателей.</span></a></p></div>
</body>
</html>