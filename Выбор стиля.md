# Критерии выбора оптимального стиля оформления текста программы

_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_Стив Макконелл. "Совершенный код"_

## Вступление

_"Programs must be written for people to read, and only incidentally for machines to execute."_
_Harold Abelson, Structure and Interpretation of Computer Programs_

_“Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.”_
_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_

Одной из важных характеристик качества разрабатываемого продукта является _удобочитаемость_ (_readability_) программного кода, которая во многом определяет степень затрат на его сопровождение и развитие.

Основным средством поддержание удобочитаемости кода на проекте является установление общего свода правил форматирования кода программы, что, несомненно, должно оказывать положительное влияние на качество кода и его удобочитаемость. Во-первых, это формирует у программистов определенные привычки относительно тех языковых конструкций, которые они ожидают увидеть в тексте программы, и тем самым может облегчить восприятие программы. Во-вторых, это оказывает дисциплинирующее воздействие, поскольку требование выполнения этих правил вынуждает программистов внимательнее относиться к тому, что и как они пишут.

Тем не менее, на практике остается открытым вопрос о том, как именно должны выглядеть отдельные правила оформления кода. Эти правила часто содержат конкретные установки на то, например, когда и как использовать пробелы, как расставлять скобки и т.п.. В то же время, отсутствуют какие-то более-менее ясные критерии того, насколько эти конкретные правила помогают повысить удобочитаемость кода. 

В этой статье я предлагаю немного поразмышлять на тему того, каким образом мы можем выработать такие критерии.

# Понимание

<!-- Например, какой с расстановки фигурных скобок предпочтительнее использовать? Стиль, диктуемый Apple, для Objective-C и Swift использует "висящие" фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Для языков Си и Си++, которые имеют гораздо большую историю и аудиторию пользователей, число предлагаемых вариантов [гораздо больше](https://en.wikipedia.org/wiki/Indentation_style).  -->

<!-- В Objective-C стиле Apple нет пробелов между ключевыми словами и аргументами в методах, но их же стиль для Swift использует пробелы между аргументами и их метками в вызовавах функций.  -->

<!-- Очевидно, что в похожих условиях должны действовать некоторые общие закономерности, которые в той или иной степени определяют "оптимальность" используемого стиля.  -->

<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). В книге "Язык программирования Си" Б. Керниган и Д. Ритчи пишут: -->

<!-- > Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте. -->

<!-- Итак, если программы в первую очередь должны писаться для того, чтобы люди могли их читать, то оформление программного кода является задачей такой же степени важности, как и задача разработки алгоритмов и структуры программы. Это значит, что программист должен тратить на это свое время и силы. -->

<!-- (Если, конечно, не говорить об экстремальных случаях, когда вам приходится быстро править ошибку в программе складского учета под присмотром раздраженного клиента с автоматом Калашникова – незабываемый опыт, который получили некоторые программисты в лихих 90-х.) -->

<!-- В чем же состоит основная цель этой задачи? Это задача формирования такого визуального представления и информационного наполнения текста программы, которое бы облегчило (т.е. требовало бы меньше усилий) программисту понимание этой программы и формирование соответствующей ей корректной статической и динамической ментальной модели. Или, если короче, оформление программы должно облегчать ее "чтение".  -->
<!-- <\!-- Слово "чтение" я взял в кавычки, потому что это не совсем привычное чтение, о котором мы говорим, когда мы читаем книгу. Текст программы отличается от текста в книге тем, что он гораздо более сильно структурирован, -\-> -->
<!-- Процесс понимания можно разделить на следующие подзадачи: -->
<!-- - непосредственно чтение текста; -->
<!-- - распознавание синтаксических элементов программы (различение имен переменных, функций, констант, операций над ними); -->
<!-- - понимание логической роли отдельных переменных и функций. -->
<!-- - распознование элементов рекурсивной логической структуры; -->

Имея текст программы, в конечном итоге мы хотим прийти к максимально полному её пониманию. Понятно, что именно этот процесс понимания, перехода от незнания к знанию, мы и хотим облегчить (оптимизировать) с помощью оформления кода программы каким-то специальным образом.

Очевидно, что имея "текст" программы, мы будем его "читать", как мы обычно читаем тексты. Это значит, что нам надо, оптимизировать процесс чтения.
Но "чтение" программы в целом отличается от того, как мы обычно читаем прозу.

Во-первых, программы лексически и синтаксически отличаются от обычных текстов. Лексически, они составлены из ограниченного набора слов, где некоторые слова являются ключевыми словами языка программирования, а другие используются как идентификаторы для именования, например, переменных или методов. Синтаксически, программы организованны иначе, чем обычные тексты. Тексты программ отличаются широким использованием формально определенных структур, обозначаемых в тексте с помощью специальных синтаксических конструкций.[^2]

Во-вторых, существует и семантическое отличие. Восприятие обычного текста, в общем случае, состоит из двух параллельных фаз: восприятие самого текста и осмысление того, о чем он повествует. Восприятие текста программы дополнительно требует осознания операционной семантики программы, то есть того, как изменяется состояние программы в процессе её выполнения.

Такая структурированность текстов программ и необходимость понимания операционной семантики приводят к тому, что чтение программ не является полностью линейно последовательным. В процессе чтения программы программисту приходится часто переходить от одного места в программе к другому, осуществлять поиск отдельных ее элементов. Таким образом, нам надо также оптимизировать текст программы для задачи навигации по коду и более явного отражения её структуры.

Давайте посмотрим подробнее, во-первых, на то, что нам известно о механизмах чтения, и, во-вторых, на то, что нам известно о особенностях чтения и восприятия текстов программ.

## Как мы читаем обычные тексты[^1]

<!-- ### Результаты исследований -->
("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)

Когда мы читаем, наши глаза непрестанно совершают быстрые механические (т.е. не контролируеммые сознанием) движения, называемые _саккадами_ (_saccades_). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения (2° центральной области видимости) для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (_fixations_) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

<!-- При чтении мы не получаем семантическую информацию из нижележащей строки. Однако в задачах поиска слова в отрывке, читатающие иногда могут получить информацию из нижней строки. -->

Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа, но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области).

Порядка 10–15% времени читающие переводят свой взгляд назад в тексте (_regressions_), чтобы повторно прочитать то, что уже было прочитано. С возрастанием трудности текста увеличивается продолжительность фиксаций и частота регрессий, а длина саккад уменьшается. 

Размер _перцептивной области_ (_perceptual span_)(_области восприятия_) относительно невелик: в случае алфавитных орфографий (напр. английский, французский, голландский) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки. Наблюдается некоторая вариативность в размере действительной области восприятия от фиксации к фиксации.

Область видимости, необходимая для идентификации фиксированного слова (_область идентификации_)(_identification span_) меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации.

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове. Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определения должно ли следующее слово быть пропущено.

<!-- Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации. -->

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Существуют данные, что при разделении слов в текста на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно. 

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (_preferred viewing location_), где-то на расстоянии 1/4 длины слова от его начала. 

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове происходит ближе к предпочитаемой точке, чем когда этот промежуток оказывается за ее пределами.

Иногда используют понятие _оптимальная позиция взгляда_ (_optimal viewing position_). Оптимальная позиция взгляда – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.


### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
|------------------|-----------------------------------------|----------------------------------|
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |

В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим эксцентриситетом (отклонением от центра сцены), она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени). При сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена.


<!-- #### Выводы -->
<!-- 1. Оптимальная длина идентификатора составляет приблизительно не более 12 букв (4 слева и 8 справа от начальной точки фиксации). При такой длине мы будем способны распозать слово за одну фиксацию и совершить точный переход к следующему слову. -->

<!-- Следущая, субоптимальная длина составляет около 20 букв. Она соответствует двум фиксациям: первая в позиции 4 буквы от начала слова, вторая, после саккады длиной 8 букв, в позиции 12 букв от начала, так что справа остается еще 8 букв. -->

<!-- 2. Пробелы имеют значения. Они помогают нам распознавать слова, предсказывая следующие из текущей позиции, и позволяют совершать более точные саккады. -->

<!-- 3. Ограничивая длину строки, мы уменьшаем эксцентриситет слов в тексте, облегая тем самым визуальный поиск и уменьшая число саккад, необходимых для возврата к началу строки. -->

<!-- 4. Для облегчения навигации при визуальном поиске, код должен быть организован в виде рекурсивной структуры логически связанных групп. -->


## Результаты исследований механизмов понимания программ[^3]
### Концепции и терминология
_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста. 

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, пограмма сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные элементы кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции. 

_Правила написания программ_ (_rules of programming discourse_) 
охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

### Модель понимания от общего к частному 
В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня. 

### Понимание от частного к общему
Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

### Оппортунистическая и систематические стратегии
При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.

### Роль идентификаторов[^4]
Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода. Таким образом, если некоторый стиль именования значительно  увеличивает скорость восприятия кода, это должно существенно повлиять на общее понимание программы. 

В общем случае, использование целых слов в идентификаторах приводит к лучшему восприятию программы, чем при использовании сокращений.

Идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.

При исследовании влияния разных видов заполнений промежутков между словами на время чтения было обнаружено, что скорость уменьшалась на 10-75% в зависимости от вида заполнителя. 

## Обобщение результатов

Приведенные результаты позволяют нам предложить следующее:
1. Идентификаторы играют важнейшую роль для обеспечения удобочитаемости программного кода. Они занимают его большую часть и часто играют роль маяков, позволяющих идентифицировать характерные структурные части программы. Основные требования к идентификаторам – это их краткость и выразительность. Чем идентификатор короче, тем он легче для чтения, поиска и запоминания. Кроме того, использование коротких имен приводит к меньшему эксцентриситету кода (более коротким строкам), что облегчает чтение и поиск. Требование выразительности означает, что в области контекста использования, идентификатор должен позволять однозначно определять роль обозначаемого им элемента программы. 

Требования краткости и выразительности могут очевидным образом конфликтовать друг с другом, поскольку выразительность может требовать использования более длинных имен. Поэтому нам имеет смысл сделать оценку допустимой рекомендованной длины идентитификатора. В качестве такой оценки можно использовать длину в 14 символов, как максимальную длину коротких идентификаторов. Это число немного больше средней области распознавания, но меньше области восприятия, и мы рассчитываем на то, что распознование этого слова не потребует более 1-2 фиксаций. Следующий приемлимый порог – это длина порядка 22 символов (предыдущая длина плюс 8 символов для дополнительной саккады). При этом мы рассчитываем, что для распознавания этого имени не потребуется более 2-3 фиксаций. 

 На практике, однако, приходится использовать имена, длина которых выходят за предлагаемые пределы. Например, когда имя включают в себя некоторое стандартное именование группы, к которой относится данный элемент, как в `PreferencesViewController`. В этом случае лучше значимую, уникальную часть имени располагать в начале слова. При этом мы рассчитываем, что мы сможем распознать уникальную часть имени уже при первой фиксации, и в то же время нам не потребуется больших усилий для распознания "стандартного дополнения". 

В общем случае, каждый случай использования длинных идентификаторов должен рассматриваться как вынужденный компромисс. 

2. Пробелы важны. Использование любого другого разделителя требует больший усилий при чтении. Поэтому, например, имеет смысл разделять пробелом имя функции и список ее параметров/аргументов, в случае, если их совокупная длина превышает размер области распознавания.

3. Для облегчения навигации по тексту программы и отображения различных ее частей на логическую структуру программы, необходимо соответствующим образом формировать ее визуальное представление. 

В идеальном случае, в программе должны быть возможным легко выделить области, относящиеся к синтаксически или семантически связанным элементам.

Например, в определении функции нам необходимо визуально разделить объявление функции, включающее её имя, возвращаемый тип, список параметров и
тело функции. Внутри тела функции необходимо разделить код инициализации начальных переменных, тело основного алгоритма, формирование и возвращение результата. В свою очередь, внутри кода инициализации нам надо разделить область типов, имен переменных и присваиваемых им значений.

Таким образом, мы разделяем области кода как по вертикали, так и по горизонтали. В первом мы случае выполняем эти разделения посредством добавления пустых строк. Во втором – мы используем выравнивание.

В общем случае, выравнивание схожих элементов в последовательности однородных строк значительно облегчает чтение и поиск. Фактически, в этом случае мы используем табличную форму представления информации. При этом в некоторых случаях имеет смысл выравнивать не по левому, а по правому краю. Например, при представлении блока строк в табличной форме, содержащих однотипные структурированные списки идентификаторов, в котором некоторые идентификаторы оканчиваются одним и тем же словом на всех строках. Или при выравнивании пар ключевое слово/значение в таких языках как С#, Objective-C, Swift.

В принципе, не обязательно формировать вертикальную линию разделения между областями кода. Например, пусть имеется последовательность строк, каждая из которых содержит инициализацию некоторой переменной, то есть имеет вид: имя переменной, оператор присваивания, присваиваемое значение. В этом случае, расположения этих строк таким образом, что длина имен переменных медленно возрастает от первой строки к последней, может быть достаточным для четкого визуального разделения групп имен переменных и их значений.

4. Надо стремиться к тому, чтобы основная масса кода была сконцентрированна в области первых 60 символов, и длина строки в общем случае не превышала 80 символов.

Это ограничение способствует формированию сбалансированных двумерных визуальных структур, о которых мы говорили выше, и облегчает чтение, за счет облегчения возврата к началу строки.

5. Расстановка фигурных скобок.
На сегодняшний день в языках с Си-подобным синтаксисом существуют два основных способа расстановки фигурных скобок: One Truce Brace Style (1TBS) и Allman. Остальные [известные варианты](https://en.wikipedia.org/wiki/Indentation_style) либо являются их вариациями, либо выглядят достаточно экзотически и, соответвенно, популярностью не пользуются.

В 1TBS открывающая фигурная скобка располагается в конце строки, содержащей соответствующее контрольное утверждение. В стиле Allman, эта скобка располагается на следующей линии с тем же отступом, как и связанное утверждение.

В общем случае стиль Allman предпочтательнее, поскольку в нем открывающая и закрывающая скобки располагаются в одной колонке, что значительно облегчает поиск парной скобки. Кроме того, поскольку скобки располагаются на отдельных строках, блок кода внутри них явно отделен от заголовка конструкции.

Тем не менее, есть случаи, когда 1TBS может оказаться предпочтительнее, чем Allman. Например, в случае короткого условия в операторе `if`, когда код внутри скобок содержит 1-2 строки. При этом использование стиля Allman может приводить к развалу визуальной структуры кода, так что заголовок конструкции, оказывается слишком слабо связан с кодом внутри скобок. 

Таким образом, выбор того или иного способа расстановки скобок должен осуществляться программистом в каждом конкретном случае, для того чтобы сформировать оптимальное визуальное представление конкретной части кода.

<!-- 6. Использование символов табуляции. -->
<!-- Единственная причина использования символов табуляции – это "оптимизация" процедуры редактирования. -->
<!-- Вместе с тем, они добавляют в текст программы скрытую структуру, которая часто приводит к разрушению визуального преставления кода при переносе из одного окружения в другое. Например, вы можете быть счастливы установив ширину символа табуляции в четыре пробела на своем компьютере, но на github ваш код скорее всего будет иметь некорректные отступы. Его визуальная структура будет нарушена.  -->
<!-- Вывод один – не используйте пробелы. Изучите возможности своего редактора. -->


<!-- Например, какой с расстановки фигурных скобок предпочтительнее использовать? Стиль, диктуемый Apple, для Objective-C и Swift использует "висящие" фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Для языков Си и Си++, которые имеют гораздо большую историю и аудиторию пользователей, число предлагаемых вариантов [гораздо больше](https://en.wikipedia.org/wiki/Indentation_style).  -->

<!-- В Objective-C стиле Apple нет пробелов между ключевыми словами и аргументами в методах, но их же стиль для Swift использует пробелы между аргументами и их метками в вызовавах функций.  -->

<!-- Очевидно, что в похожих условиях должны действовать некоторые общие закономерности, которые в той или иной степени определяют "оптимальность" используемого стиля.  -->

<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). В книге "Язык программирования Си" Б. Керниган и Д. Ритчи пишут: -->

<!-- > Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте. -->

## Резюме

Подводя итоги, можно сказать, что основными критериями выбора правил оформления программного кода должно быть повышение удобочитаемости текста программы и формирование ее визуального представления таким образом, чтобы оно максимально возможным образом отражало синтактическую и семантическую структуру программы. 
При этом удобочитаемость программы улучшается при разделении идентификаторов пробелами, и, как правило, ухудшается при увеличении их длины. 

Структурирование текста программы связано с формированием двумерной визуальной структуры, в которой синтаксически и семантически связанные элементы программы образуют геометрически сбалансированные области. Иными словами мы отражаем структуру программу в некоторое изображение. Для оценки качества этого представления можно попытаться оценить его отодвинувшись от экрана и разфокусировав взгляд. 



--
[^1]: [Eye Movements in Reading and Information Processing: 20 Years of Research. Keith Rayner – University of Massachusetts at Amherst](https://www.semanticscholar.org/paper/Eye-movements-in-reading-and-information-20-years-Rayner/87c8a7be8d5e2e2209e766c3e28a3e8ee5babb64)
[^2]: [Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif](https://dl.acm.org/doi/10.5555/2820282.2820320)
[^3]: [Theories, tools and research methods in program comprehension: Past, Present and Future. Margaret-Anne Storey](http://www.ptidej.net/courses/inf6306/fall10/slides/course8/Storey06-TheoriesMethodsToolsProgramComprehension.pdf)
[^4]: [An Eye Tracking Study on camelCase and under_score Identifier Styles. Bonita Sharif and Jonathan I. Maletic – Department of Computer Science Kent State University](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf)
[^5]: [Achieving Software Quality through Source Code Readability, Phillip Relf](https://www.researchgate.net/publication/238443707_Achieving_Software_Quality_through_Source_Code_Readability)
[^6]: [Relating Identifier Naming Flaws and Code Quality: An Empirical Study. Simon Butler](https://ieeexplore.ieee.org/document/5328661)