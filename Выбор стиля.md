# Критерии выбора оптимального стиля оформления текста программы

_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_Стив Макконелл. "Совершенный код"_

## Вступление
Как правило все мы легко соглашаеся с тем утверждением, что стиль оформления программного кода имеет важное значение для создания качественной программы, облегчает ее понимание, а значит и сопровождение и отладку. Проблема однако в том, как осуществляется выбор конкретных правил такого стиля. На практике, стиль часто определяется по "праву первого", исходя из привычек одного или небольшой группы гуру-программистов, начинающих работать на проектом. При этом сами правила выбираются на основе установившихся привычек этих программистов, либо заимствуются из "авторитетного" источника. В обоих случаях отсутствуют какие-то разумные объяснения того, какие объективные критерии использовались при выборе этих правил. 

Например, какой метод расстановки фигурных скобок предпочтительнее использовать в Си-подобных языках? Большая часть общедоступных стилей для Objective-C и Swift используют "висящие" скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Языки Си и Си++ имеют гораздо большую историю и аудиторию пользователей, и как результат число вариантов для них больше [[https://en.wikipedia.org/wiki/Indentation_style]]. 

Однако, кажется очевидным то, что в похожих условиях должны действовать некоторые общие закономерности, которые в той или иной степени определяют "оптимальность" используемого стиля. Однако, мне нигде не удалось найти подобные обоснования.

В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). В книге "Язык программирования Си" Б. Керниган и Д. Ритчи пишут:

> Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте.

Если считать, что разработка программного обеспечения является инженерной деятельностью (по крайней мере, мне хочется надеяться на это) очень странно наблюдать ситуацию, когда решение инженерной задачи, связанное с повышением качества разрабатываемого продукта и уменьшением затрат на его сопровождение, происходит в отсутствии каких-либо сформулированных критериев успешности ее решения. Наверно, можно сказать, что инженерная деятельность на деле подменяется некоторыми религиозными ритуалами. 

В этой статье, не претендую на истину в первой инстанции, я хочу предложить объективные варианты выработки таких критериев. 

## Основная цель задачи формирования стиля программного кода.

_"Programs must be written for people to read, and only incidentally for machines to execute."_
_Harold Abelson, Structure and Interpretation of Computer Programs_

_“Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.”_
_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_

Итак, если мы принимаем ту точку зрения, что программы в первую очередь должны писаться для того, чтобы люди могли их читать, мы должны также и согласиться с тем, что оформление программного кода является задачей такой же степени важности, как и задача разработки алгоритмов и структуры программы. Это то, на что программист должен тратить время и силы. Если не говорить об экстремальных случаях, когда вам приходится быстро править ошибку в программе складского учета под присмотром недовольного пользователя с автоматом Калашникова – незабываемый опыт, который получили некоторые программисты в лихих 90-х.


В чем же состоит основная цель этой задачи? Это задача формирования такого визуального представления и информационного наполнения текста программы, которое бы облегчило (т.е. требовало бы меньше усилий) программисту понимание этой программы и формирование соответствующей ей корректной статической и динамической ментальной модели. Или, если короче, оформление программы должно облегчать ее "чтение". 
<!-- Слово "чтение" я взял в кавычки, потому что это не совсем привычное чтение, о котором мы говорим, когда мы читаем книгу. Текст программы отличается от текста в книге тем, что он гораздо более сильно структурирован, -->
Процесс понимания можно разделить на следующие подзадачи:
- непосредственно чтение текста;
- распознавание синтаксических элементов программы (различение имен переменных, функций, констант, операций над ними);
- понимание логической роли отдельных переменных и функций.
- распознование элементов рекурсивной логической структуры;

Очевидно, что мы хотим, чтобы выбранный нами стиль оформления программного кода оптимизировал (облегчал) выполнение всех этих задач в частности и в общем.

## Чтение

Текст программы сильно структурирован, в отличии от обычного текста. И очень часто, это не простое чтение, которое мы наблюдаем при чтении книг. При распозновании логической структуры, программисты ищут, так называемые маяки – некоторые узнаваемые атрибуты программного кода, такие как специфические переменные, управляющие конструкции, выражения. Тем не менее, психо-физиологические механизмы, задействованные в процессе чтения, остаются теми же и, к счастью для нас, хорошо изучены.


### Результаты исследований
("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)

Когда мы читаем, наши глаза непрестанно совершают быстрые движения называемые _саккадами_ (saccades). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (fixations) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа (2° центральной области видимости), но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области).

Размер _перцептивной области_ (_области восприятия_)(perceptual span) относительно невелик: в случае алфавитных орфографий (напр. английский, французский, голландский) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки. Наблюдается некоторая вариативность в размере действительной области восприятия от фиксации к фиксации.

При чтении мы не получаем семантическую информацию из нижележащей строки. Однако, когда задача состояла в том, чтобы найти целевое слово в отрывке, читатели иногда могли получить информацию из нижней строки.

Область видимости, необходимая для идентификации фиксированного слова (_область идентификации_)(_identification span_) меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации.

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове.

Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации.

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определния должно ли следующее слово быть пропущено.

Существуют данные, что при разделении слов в текста на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно. 

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (preferred viewing location), где-то на расстоянии 1/4 длины слова от его начала. 

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове была ближе к предпочитаемой точке, чем когда этот промежуток находился за ее пределами.

Некоторые исследователи оперируют понятием _оптимальная позиция взгляда_ (optimal viewing position). Оптимальная позиция взгляда – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда, ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.


### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |

В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим отклонением от центра сцены, она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени).

Также при сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена.


#### Выводы
1. Оптимальная длина идентификатора составляет приблизительно не более 12 букв (4 слева и 8 справа от начальной точки фиксации). При такой длине мы будем способны распозать слово за одну фиксацию и совершить точный переход к следующему слову.

Следущая, суб-оптимальная длина составляет около 20 букв. Она соответствует двум фиксациям: первая в позиции 4 буквы от начала слова, вторая, после саккады длиной 8 букв, в позиции 12 букв от начала, так что справа остается еще 8 букв.

2. Пробелы имеют значения. Они помогают нам распознавать слова, предсказывая следующие из текущей позиции, и позволяют совершать более точные саккады.

3. Ограничивая длину строки, мы уменьшаем эксцентриситет слов в тексте, облегая тем самым визуальный поиск и уменьшая число саккад, необходимых для возврата к началу строки.

4. Для облегчения навигации при визуальном поиске, код должен быть организован в виде рекурсивной структуры логически связанных групп.


## Результаты исследований механизмов понимания программ

### Theories, tools and research methods in program comprehension
#### Концепции и терминология

_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста. 

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, пограмма сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные атрибуты кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции. 

_Правила написания программ_ (_rules of programming discourse_) 
охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

#### Модель понимания от общего к частному 
В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня. 

#### Понимание от частного к общему
Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

#### Оппортунистическая и систематические стратегии
При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.


### An Eye Tracking Study on camelCase and under_score Identifier Styles

Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода. Таким образом, если некоторый стиль именования значительно  увеличивает скорость восприятия кода, это должно существенно повлиять на общее понимание программы. 

Было показано, что использование целый слов в идентификаторах как правило приводит к лучшему восприятию программы, чем при использовании сокращений.

Также, идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (имеют больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.



