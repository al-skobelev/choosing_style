# Выбор стиля. Оптимизация визуального представления программы.
<!-- Визуальное восприятие в программировании -->


_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_— Стив Макконелл, Совершенный код_

## Вступление

_Programs must be written for people to read, and only incidentally for machines to execute._
_— Harold Abelson, Structure and Interpretation of Computer Programs_

_Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write._
_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_


<!-- Программы пишутся для людей. И не только для тех, кто будет использовать эти программы, но и для тех, кто впоследствии будет их сопровождать и дорабатывать. -->
<!-- То, насколько легко или сложно это будет делать, зависит, в частности, и от того, насколько удобочитаемым и понятным будет их исходный код.  -->

<!-- _Удобочитаемость_ (_readability_) программного кода – одна из важных характеристик качества разрабатываемого продукта, которая во многом определяет степень затрат на его сопровождение и развитие.  -->

<!-- Таким образом, перед разработчиком стоит не только задача разработки программы как сложно структурированной совокупности инструкций и организации этой совокупности   -->

Программа существует не только как процесс выполняемый на компьютере, но и в виде развиваемого и сопровождаемого исходного кода. И для этих двух её ипостасей у неё существуют свои пользователи: конечные пользователи программы и сами её разработчики. Наверно, не будет ошибкой сказать, что удовлетворенность разработчиков как пользователей во многом определяет насколько довольны оказываются и конечные пользователи.

Хорошая новость состоит в том, что, хоть и не всегда и не в полной мере, удовлетворенность разработчиков зависит от самих разработчиков. Плохая же состоит в том, что даже в тех случаях, когда это возможно, не всегда удается это сделать. 

Удовлетворенность разработчиков определяется тем, насколько легко дается им сопровождение и развитие программы. И одним из факторов, определяющих степень этой легкости,несомненно, является удобочитаемость текста программы.

Основным средством поддержания удобочитаемости кода в процессе разработки обычно является установление общего свода правил форматирования (стиля) исходного кода разрабатываемой программы. Уже само по себе наличие таких правил, несомненно, оказывает положительное влияние на качество кода и его удобочитаемость, так как формирует у программистов определенные привычки относительно тех языковых конструкций, которые они ожидают увидеть в тексте программы, а необходимость следования заданным правилам играет дисциплинирующую роль, вынуждая внимательнее относиться к написанию кода и предупреждая возможные конфликты, вызванные личными предпочтениями отдельных разработчиков.

Тем не менее, сами правила часто вызывают вопросы, поскольку критерии их выбора неясны и не соответствуют аналогичным правилам в других подобных стилях. 

Например, какой стиль расстановки фигурных скобок предпочтительнее использовать? 

Стиль, диктуемый Apple, для Objective-C и Swift использует «висящие» фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Однако [не все разработчики согласны с этим выбором, и некоторые предпочитают стиль Allman](https://ericasadun.com/2015/12/28/swift-bracing/), в котором открывающая скобка расположена на новой строке. Языки Си и Си++ имеют гораздо большую аудиторию пользователей, чем Objective-C и Swift, а поэтому и число предлагаемых вариантов расстановки скобок [больше](https://en.wikipedia.org/wiki/Indentation_style).

_«Положение скобок не так важно»_ пишут Б. Керниган и Д. Ритчи в книге «Язык программирования Си». Но существование различных стилей расстановки фигурных скобок, и групп программистов, готовых отстаивать выбранный ими стиль, ставит под сомнение этот тезис классиков. Несоменно, в процессе разработки существуют и гораздо более важные вопросы, чем вопрос о расстановки скобок, но и этот вопрос, несмотря на свою сравнительную малость, все же заслуживает внимания, поскольку является одной из тех деталей, которые сладываясь, как элементы мозаики, формируют окончательный вид программы и определяют, таким образом, ее удобочитаемость.

Проблема с правилами стиля, видимо, кроется в том, что они задают конкретные детали оформления кода, но не говорят о том, что же такое _удобочитаемость_, и как они помогают ее достичь. Формальный подход приводит к ситуации, в которой цель подменяется средствами. Непонятно, в чем наше светлое будущее, но главное – идти туда строем и в ногу.

Очевидно, что общие механизмы восприятия и обработки человеком визуальной информации и текстов, в частности, обладают возможностями и ограничениями, и эти возможности и ограничения в конечном счете определяют то, как много усилий потребуется для корректного и полного восприятия представленной информации. Следовательно удобочитаемость текста определяется тем, насколько его визуальное представление учитывает специфические особенности этих общих механизмов восприятия, и поэтому является его объективной характеристикой.

<!-- Учитывая множество различных стилей, можно предположить, что как минимум некоторые из них не учитывают особенности механизмов восприятия, и, вероятно, являются следствием интуиции и привычек их составителей или воспроизводят правила из «авторитетного» источника. <\!-- В этом смысле удобочитаемость оказывается субъективным параметром. -\-> -->

Программы отличаются от обычных текстов, и процесс их чтения отличается от чтения прозы. Программы составлены из ограниченного набора слов и синтаксически организованны иначе, чем обычные тексты: в них широко используются формально определенные структуры, обозначаемые в тексте с помощью специальных синтаксических конструкций. Кроме того, существует и семантическое отличие. Восприятие обычного текста, в общем случае, состоит из двух параллельных фаз: восприятие самого текста и осмысление того, о чем он повествует. Когда речь идет о коде, осмысление означает осознание синтактической и семантической структур программы, но также включает и осознание операционной семантики программы, то есть того, как изменяется состояние программы в процессе её выполнения.[^2]  Как результат, в процессе чтения программы программисту приходится также «сканировать» текст, переходить от одного места в программе к другому, осуществлять поиск отдельных элементов ее структуры.

Легкость восприятия визуального представления структуры программы оказывается не менее важной, чем легкость восприятия ее текста как такового. 

Таким образом, кроме кроме оптимизации непосредственно чтения, необходимо оптимизировать задачу поиска в иерархической визуальной структуре. Фактически, мы приходим к задаче формирования изображения программы, оптимальным способом отражающим ее структуру, то есть изображения, в котором отдельные, легко различаемые его области соотносятся со структурными элементами программы. 

Давайте посмотрим подробнее, во-первых, на то, что нам известно о механизмах чтения, и, во-вторых, на то, что нам известно о особенностях чтения и восприятия текстов программ.

## Особенности зрения человека

[Поле зрения](https://ru.wikipedia.org/wiki/Поле_зрения) человека достаточно велико: 55° вверх, 60° вниз, 90° наружу (то есть суммарное поле зрения двумя глазами — 180°) и 60° внутрь. При этом область максимальной остроты зрения (около 1' для человека с нормальным зрением) достаточна узка и быстро падает от центра к границам. 
Подобным же образом от центра к краю падает и способность различать цвета, причем это изменение различно для разных цветовых компонент. Можно сказать, что, двигаясь от центра человеческой сетчатки к периферии, мы как бы оказываемся на более ранних этапах эволюции, переходя от наиболее высоко организованных структур к примитивному глазу, который различает лишь простое движение теней. 

Свет пройдя сквозь роговицу, хрусталик и стекловидное тело попадает на сетчатку, где под сетью капилляров и нейронов расположены фоторецепторы: колбочки и палочки.  
Всего на зрительной сетчатке располагаются порядка 7 млн. колбочек и более 120 млн. палочек. Колбочки являются аппаратом цветового зрения, в то время как палочки, обладающие гораздо большей чувствительностью, формируют сумеречное, черно-белое видение. 

По чувствительности к свету с различными длинами волн различают три вида колбочек. Колбочки S-типа чувствительны в фиолетово-синей (S от англ. Short — коротковолновый спектр), M-типа — в зелено-желтой (M от англ. Medium — средневолновый), и L-типа — в желто-красной (L от англ. Long — длинноволновый) частях спектра.

В области желтого пятна, которое находится в визуальном центре сетчатки, концентрация колбочек масимальна. 

Края человеческой сетчатки не дают даже зрительного ощущения; когда они стимулируются движущимся объектом, они вызывают только рефлекторный поворот глаз к этому объекту, после чего глаз воспринимает его наиболее высокоорганизованной частью сетчатки.[^7]

В современной нейропсихологии существует представлении о двух различных зрительных системах: так называемого «амбьентного зрения» (от фр. ambiance = окружение) и «фокального зрения». В то время как первая, эволюционно более древняя, ответственна за динамическую пространственную локализацию, вторая занимается идентификацией объектов[^9].

Обследование окружения и выбор объектов для детальной обработки осуществляется с помощью движений головы и тела, на которые накладывается тонкий узор движений глаз.  Наиболее известной их разновидностью являются _саккады_ — чрезвычайно быстрые скачки баллистического типа, меняющие положение глаз в орбите и позволяющие выделять фрагменты сцены для последующей _фиксации_. Если фиксируемый объект движется, то глаза начинают отслеживать его в режиме динамической фиксации с помощью гладких, следящих движений. Когда наблюдатель сам перемещается в пространстве, относительная неподвижность проекции окружения на сетчатку поддерживается с помощью _нистагма_: пилообразных движений, медленная фаза которых компенсирует собственное движение, а быстрая — возвращает глаза в исходное положение. Во время фиксации наши глаза также не остаются неподвижными, а совершают мельчайшие микродвижения нистагмоидного типа.



Известен случай, когда двое пациентов знаменитого советского офтальмолога Авербаха М.И., адвокатов по профессии, вследствие глазных заболеваний имели противоположные нарушения зрения: у первого страдало центральное зрение, а у второго — периферическое (поле зрения его было сужено почти до точки фиксации). В здании судебного учреждения, где они работали, был длинный темный коридор, и оба пациента каждый день проходили по нему. Первый из них, совершенно не способный прочесть ни одной строчки, свободно двигался по коридору, не нуждаясь в посторонней помощи. Второй, легко читавший мельчайший газетный шрифт, войдя в коридор, беспомощно останавливался и ждал, пока первый не проводит его в зал заседаний
<!-- То, что и как мы видим, определяется определяется как особенностями нашего глаза, так и в гораздо большей степени тем, как наш мозг обрабатывает полученную информацию. -->

<!-- ! Несмотря на то, что глаз имеет большое поле зрения, только небольшая центральная область его со 100% четкостью. Кроме четкости от центра к периферии также падает и различение цветов.  -->

<!-- изображение объектов в визуальных моделях является одной из проблем формообразования, с которой постоянно сталкивается большинство художников. Изображение объекта подразумевает собой сравнение, соотнесение объекта-модели и его зрительного образа. Образ не представляет собой точной механической копии воспринимаемого объекта. В связи с этим возникает ряд вопросов. Какие условия должны быть соблюдены, чтобы образ стал узнаваемым? Какими визуальными понятиями пользуется художник при изображении предметов? Каковы причины огромного разнообразия этих визуальных понятий?  -->

## Визуальное восприятие изображения текста

<!-- Познавательные способности нашего сознания (а художественное творчество является одной из них) тщательно отыскивают порядок. Но в то время как наука извлекает из многообразия явлений закономерности порядка, искусство использует явление для того, чтобы показать порядок в разнообразии.  -->
Искусство программиста заключается в том, чтобы, организовав визуальный порядок в разнообразии, облегчить возможность выявления его закономерностей.
<!-- Форма кода -->

<!-- Формирование визуального представления (изображения) кода программы это часть ремесла программиста, которая находится на грани искусства. -->
<!-- Энтропия кода и энтропия изображения (визуального представления) кода -->
<!-- Большое видится на расстоянии, лицом к лицу лица не увидать. -->
<!-- Типографика -->
<!-- Разделение полушарий -->
<!-- Арнхейм -->
<!-- психология зрительного восприятия -->
<!-- Ассиметрия левой и правой стороны -->


## Как мы читаем обычные тексты[^1]

<!-- ### Результаты исследований -->
<!--("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)-->

Когда мы читаем, наши глаза непрестанно совершают быстрые механические (т.е. не контролируеммые сознанием) движения, называемые _саккадами_ (_saccades_). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения (2° центральной области видимости) для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (_fixations_) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

<!-- При чтении мы не получаем семантическую информацию из нижележащей строки. Однако в задачах поиска слова в отрывке, читатающие иногда могут получить информацию из нижней строки. -->

Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа, но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области).

Порядка 10–15% времени читающие переводят свой взгляд назад в тексте (_regressions_), чтобы повторно прочитать то, что уже было прочитано. С возрастанием трудности текста увеличивается продолжительность фиксаций и частота регрессий, а длина саккад уменьшается. 

Размер _области восприятия_ (_perceptual span_) относительно невелик: в случае алфавитных орфографий (напр. для европейских языков) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки.

_Область идентификации_ (_identification span_), то есть область видимости, необходимая для идентификации фиксированного слова меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации.

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове. Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определения должно ли следующее слово быть пропущено.

<!-- Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации. -->

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Существуют данные, что при разделении слов в текста на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно. 

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (_preferred viewing location_), где-то на расстоянии 1/4 длины слова от его начала. 

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове происходит ближе к предпочитаемой точке, чем когда этот промежуток оказывается за ее пределами.

_Оптимальная позиция взгляда_ (_optimal viewing position_) – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.

### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
|------------------|-----------------------------------------|----------------------------------|
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |



В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим эксцентриситетом (отклонением от центра сцены), она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени). При сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена.



## Результаты исследований механизмов понимания программ[^3]

### Концепции и терминология

_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста. 

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, пограмма сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные элементы кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции. 

_Правила написания программ_ (_rules of programming discourse_) 
охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

### Модель понимания от общего к частному 

В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня. 

### Понимание от частного к общему

Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

### Оппортунистическая и систематические стратегии

При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.

### Роль идентификаторов[^4]

Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода.

В общем случае, использование целых слов в идентификаторах приводит к лучшему восприятию программы, чем при использовании сокращений.

Идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.

При исследовании влияния разных видов заполнений промежутков между словами на время чтения было обнаружено, что скорость уменьшалась на 10-75% в зависимости от вида заполнителя. 



## Обобщение результатов

### Визуальное представление

!!! Говоря о визуальном представлении программы в целом, мы должны помнить, что целое наш глаз воспринимает зрением, обладающим малой остротой и цветовосприятием.


Визуальное представление программы, это то, что изначально видит читатель, до того, как погрузится в глубину ее текста. Это то, с чем он имеет дело, когда выныривает из его глубин, для того, чтобы окинуть взглядом ее общую структуру и понять, куда двигаться дальше.

Если то, что он видит слабо соответствует структуре программы, то ему не остается ничего другого, как двигаться наугад, мучительно продираясь сквозь заросли синтаксиса.

Как формируется эта картинка?
Мы сближаем различные элементы программы, или отодвигаем их один от другого, подсказывая нашему зрению, как лучше сформировать из них графические объекты: области изображения, воспринимаемые как единое целое. 

Для облегчения навигации по тексту программы и отображения различных ее частей на логическую структуру программы, необходимо соответствующим образом формировать ее визуальное представление. В идеальном случае, в программе должны быть возможным легко выделить области, относящиеся к синтаксически или семантически связанным элементам.

Например, в определении функции нам необходимо визуально разделить объявление функции, включающее её имя, возвращаемый тип, список параметров и тело функции. Внутри тела функции необходимо разделить код инициализации начальных переменных, тело основного алгоритма, формирование и возвращение результата. В свою очередь, внутри кода инициализации нам надо разделить область типов, имен переменных и присваиваемых им значений.

Таким образом, мы разделяем области кода как по вертикали, так и по горизонтали. В первом мы случае выполняем эти разделения посредством добавления пустых строк. Во втором – мы используем выравнивание.

В общем случае, выравнивание схожих элементов в последовательности однородных строк значительно облегчает чтение и поиск. Фактически, в этом случае мы используем табличную форму представления информации. При этом в некоторых случаях имеет смысл выравнивать не по левому, а по правому краю. Например, при представлении блока строк в табличной форме, содержащих однотипные структурированные списки идентификаторов, в котором некоторые идентификаторы оканчиваются одним и тем же словом на всех строках. Или при выравнивании пар ключевое слово/значение в таких языках как С#, Objective-C, Swift.

``` 
// "Однострочное" форматирование:
// - плохо прослеживается структура выражения;
// - поиск идентификатора в списке аргументов затруднен.

try tempCoordinator.replacePersistentStore(at: tempStoreUrl, destinationOptions: dstOptions, withPersistentStoreFrom: storeUrl, sourceOptions: srcOptions, ofType: store.type)


// Совместное вырванивание пар метка/аргумент:
// + пары метка/аргумент лучше связаны;
// + список аргументов образует явно сфорированную область
// - различение меток и аргументов затруднено, и поэтому затруднен поиск аргументов 

try tempCoordinator.replacePersistentStore (at: tempStoreUrl,
                                            destinationOptions: dstOptions,
                                            withPersistentStoreFrom: storeUrl,
                                            sourceOptions: srcOptions,
                                            ofType: store.type)


// Метки атрибутов и атрибутв выравнены по отдельности:
// + Пары метка/атрибут легко идентифицируются
// + Формируются две отдельные визуальные области для меток и атрибутов,
//   что облегчает их поиск и идентификацию;
// - Ослабляются визуальные связи внутри пар для коротких меток.

try tempCoordinator.replacePersistentStore (at:                      tempStoreUrl,
                                            destinationOptions:      dstOptions,
                                            withPersistentStoreFrom: storeUrl,
                                            sourceOptions:           srcOptions,
                                            ofType:                  store.type)


// + Пары метка/атрибут легко идентифицируются
// + Формируются две отдельные визуальные области для меток и атрибутов,
//   что облегчает их поиск и идентификацию;
// + Сильны визуальные связи внутри пар.
// Несколько меняется интерпретация визуальной структуры: теперь список меток
// сильнее связан с именем метода и метки выглядят частью этого имени.

try tempCoordinator.replacePersistentStore (at: tempStoreUrl,
                            destinationOptions: dstOptions,
                       withPersistentStoreFrom: storeUrl,
                                 sourceOptions: srcOptions,
                                        ofType: store.type)
```



В некоторых случаях, не обязательно формировать вертикальную линию разделения между областями кода. Например, в случае последовательности строк, каждая из которых содержит инициализацию некоторой переменной, то есть имеет вид: имя переменной, оператор присваивания, присваиваемое значение. При этом, для четкого визуального разделения групп имен переменных и их значений может быть достато так расположить эти строки, чтобы длина имен переменных медленно возрастала от первой строки к последней (и эти имена были выровнены слева).

Надо стремиться к тому, чтобы основная масса кода была сконцентрированна в области первых 60 символов, и длина строки в общем случае не превышала 80 символов. Это ограничение способствует формированию сбалансированных двумерных визуальных структур  и облегчает переход к началу следующей строки в процессе чтения. 

!!! Длина строки в 60 символов соответсвует оптимальной длине строки, принятой в типографике. 

!!! Как известно, левая часть видимой сцены обрабатывается правым полушарием головного мозга, а правая – левым. 


### Имена

Имена играют важнейшую роль для обеспечения удобочитаемости программного кода. Они занимают его большую часть и часто играют роль маяков, позволяющих идентифицировать характерные структурные части программы. Основные требования к именам – это их краткость и выразительность. Чем имя длиннее, тем оно труднее для чтения, запоминания и поиска. Кроме того, длинные имена, как правило приводят к длинным строкам, а следовательно, к визуальному представлению с большим эксцентриситетом, что также затрудняет чтение и поиск. Требование выразительности означает, что в области контекста использования, идентификатор должен позволять однозначно определять роль обозначаемого им элемента программы. 

<!-- «Когда форма проще своего содержания, то заключенная в ней информация не достигает своей цели». -->

Требования краткости и выразительности могут очевидным образом конфликтовать друг с другом, поскольку выразительность может требовать использования более длинных, составных имен. Поэтому имеет смысл сделать оценку допустимой рекомендованной длины идентификатора. В качестве такой оценки можно использовать длину в 14 символов, как максимальную длину коротких идентификаторов. Это число немного больше средней области распознавания, но меньше области восприятия текста, и мы рассчитываем на то, что распознование такого слова не потребует более 1-2 фиксаций. Следующий приемлимый порог – это длина порядка 22 символов (предыдущая длина плюс 8 символов для дополнительной саккады). При этом мы рассчитываем, что для распознавания этого имени не потребуется более 2-3 фиксаций. 

На практике приходится использовать имена, длины которых выходят за предлагаемые пределы. Например, когда имя включают в себя некоторое стандартное именование группы, к которой относится данный элемент, как в `PreferencesViewController`. В этом случае лучше значимую, уникальную часть имени располагать в начале слова. При этом мы рассчитываем, что мы сможем распознать уникальную часть имени уже при первой фиксации, и в то же время нам не потребуется больших усилий для распознания "стандартного дополнения". 

В общем случае, каждый случай использования длинных идентификаторов (> 12-14 символов) должен рассматриваться как вынужденный компромисс. 

### Пробелы

Пробелы важны. Использование любого другого разделителя требует больший усилий при чтении. Пробелы также участвуют в формировании визуальной структуры, для разделения различных элементов синтаксической структуры программы. Поэтому, например, имеет смысл разделять пробелом имя функции и список ее параметров/аргументов, например, в случае, если их совокупная длина превышает размер области распознавания.

```
// При отсутствии пробела первый аргумент сливается с именем функции,
// что затрудняет чтение. Кроме того, нарушается визуальная структура: 
// первый аргумент связан с этим именем сильнее, чем со вторым аргументом
// в списке аргументов.

result = someFunction(firstArgument, secondArgument);
result = someFunction (firstArgument, secondArgument);
```

### Расстановка фигурных скобок.

На сегодняшний день в языках с Си-подобным синтаксисом существуют два основных способа расстановки фигурных скобок: _One Truce Brace Style_ (_1TBS_) и _Allman_. Остальные [известные варианты](https://en.wikipedia.org/wiki/Indentation_style) либо являются их вариациями, либо выглядят достаточно экзотически и, соответвенно, популярностью не пользуются.

В _1TBS_ открывающая фигурная скобка располагается в конце строки, содержащей окончание соответствующего синтаксического элемента, с которым она связана. В стиле _Allman_, эта скобка располагается на следующей линии с тем же отступом, как и начало связанного элемента.

В общем случае стиль Allman предпочтательнее, поскольку в нем открывающая и закрывающая скобки выровнены по вертикали. Это значительно облегчает поиск, например, парной открывающей скобки, поскольку требует лишь вертикального перемещения глаз. При этом на пути следования взгляда от одной скобки к другой, как правило, нет никакого текста, и поиск фактически происходит до первого символа. В 1TBS поиск осуществляется в широком секторе, причем взгляд проходит через текст, который надо анализировать, и который часто содержит вложенные пары фигурных скобок, что также может затруднять обнаружение нужной нам пары. 

Кроме того, поскольку в стиле Allman скобки располагаются на отдельных строках, блок кода внутри них визуально явно отделен от заголовка конструкции, что лучше сответствует структуре этой конструкции. В 1TBS такого явного разделения нет, особенно в случае, когда предшествующая часть занимает несколько строк.

Тем не менее, есть случаи, когда 1TBS может оказаться предпочтительнее, чем Allman. Например, в случае короткого условия в операторе `if`, когда код внутри скобок содержит 1-3 строки. В такой ситуации использование стиля Allman может приводить к развалу визуальной структуры кода, так что заголовок конструкции, оказывается недостаточно связанным с кодом внутри скобок по сравнению с окружающими элементами.

Таким образом, несмотря на то, что стиль Allman выглядит предпочтительнее, выбор того или иного способа расстановки скобок должен осуществляться программистом в каждом конкретном случае, для того чтобы сформировать оптимальное визуальное представление соответствующей части программного кода.

<!-- 6. Использование символов табуляции. -->
<!-- Единственная причина использования символов табуляции – это "оптимизация" процедуры редактирования. -->
<!-- Вместе с тем, они добавляют в текст программы скрытую структуру, которая часто приводит к разрушению визуального преставления кода при переносе из одного окружения в другое. Например, вы можете быть счастливы установив ширину символа табуляции в четыре пробела на своем компьютере, но на github ваш код скорее всего будет иметь некорректные отступы. Его визуальная структура будет нарушена.  -->


<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). -->

## Резюме

Иван Бортко писал[^7]: *«Пролог-программы иной раз напоминают стихи по эстетической привлекательности своих идей и формы».* Это утверждение выглядит несколько странно, если вспомнить, как обычно выглядят стихи. Но если говорить о ритмичности и мелодичности, присущей стихам, то становится понятно, о чем, возможно, писал автор книги о языке Пролог.

В идеале, «красивые» и хорошо продуманные технические решение должны выглядить привлекательно будучи оформленными в виде текста программы.
Конечно, на практике эстетика кода бывает сильно ограниченна внешними факторами, такими, например, как синтаксис языка.

<!-- Визуальное представление программы выразительно подчеркивает структуру программы, а  -->
<!-- Если логическая структура программы обладает такими свойствами, а стиль оформления программы выразительно подчеркивает эту структуры, то очевидно, что визуальная структура должна также обладать этими свойствами. -->

<!-- Эстетическая составляющая служит мерой качества. -->



<!-- Подводя итоги, можно сказать, что основными критериями выбора правил оформления программного кода должно быть повышение удобочитаемости текста программы и формирование ее визуального представления таким образом, чтобы оно максимально возможным образом отражало синтактическую и семантическую структуру программы.  -->
<!-- При этом удобочитаемость программы улучшается при разделении идентификаторов пробелами, и, как правило, ухудшается при увеличении их длины.  -->

<!-- Структурирование текста программы связано с формированием двумерной визуальной структуры, в которой синтаксически и семантически связанные элементы программы образуют геометрически сбалансированные области. Иными словами мы отражаем структуру программу в некоторое изображение. Для оценки качества этого представления можно попытаться оценить его отодвинувшись от экрана и разфокусировав взгляд.  -->



--
[^1]: [Eye Movements in Reading and Information Processing: 20 Years of Research. Keith Rayner – University of Massachusetts at Amherst](https://www.semanticscholar.org/paper/Eye-movements-in-reading-and-information-20-years-Rayner/87c8a7be8d5e2e2209e766c3e28a3e8ee5babb64)
[^2]: [Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif](https://dl.acm.org/doi/10.5555/2820282.2820320)
[^3]: [Theories, tools and research methods in program comprehension: Past, Present and Future. Margaret-Anne Storey](http://www.ptidej.net/courses/inf6306/fall10/slides/course8/Storey06-TheoriesMethodsToolsProgramComprehension.pdf)
[^4]: [An Eye Tracking Study on camelCase and under_score Identifier Styles. Bonita Sharif and Jonathan I. Maletic – Department of Computer Science Kent State University](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf)
[^5]: [Achieving Software Quality through Source Code Readability, Phillip Relf](https://www.researchgate.net/publication/238443707_Achieving_Software_Quality_through_Source_Code_Readability)
[^6]: [Relating Identifier Naming Flaws and Code Quality: An Empirical Study. Simon Butler](https://ieeexplore.ieee.org/document/5328661)
[^7]: Грегори Р.Л. Глаз и Мозг. М.:Прогресс, 1970
[^8]: Дэвид Хантер Хьюбел. Глаз, мозг, зрение. Мир, 1970
[^9]: Величковский Б.М. Когнитивная наука. Основы психологии познания. Academia, Смысл, 2006 