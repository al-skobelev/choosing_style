# Критерии выбора оптимального стиля оформления текста программы

_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_Стив Макконелл. "Совершенный код"_

## Вступление

_"Programs must be written for people to read, and only incidentally for machines to execute."_
_Harold Abelson, Structure and Interpretation of Computer Programs_

_“Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.”_
_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_

Одной из важных характеристик качества разрабатываемого продукта является _удобочитаемость_ (_readability_) программного кода, которая во многом определяет степень затрат на его сопровождение и развитие.

Основным средством поддержание удобочитаемости кода на проекте является установление общего свода правил форматирования кода программы, что, несомненно, должно оказывать положительное влияние на качество кода и его удобочитаемость. Во-первых, это формирует у программистов определенные привычки относительно тех языковых конструкций, которые они ожидают увидеть в тексте программы, и тем самым может облегчить восприятие программы. Во-вторых, это оказывает дисциплинирующее воздействие, поскольку требование выполнения этих правил вынуждает программистов внимательнее относиться к тому, что и как они пишут.

Тем не менее, на практике остается открытым вопрос о том, как именно должны выглядеть отдельные правила оформления кода. Эти правила часто содержат конкретные установки на то, например, когда и как использовать пробелы, как расставлять скобки и т.п.. В то же время, отсутствуют какие-то более-менее ясные критерии того, насколько эти конкретные правила помогают повысить удобочитаемость кода. 

В этой статье я бы хотел немного поразмышлять на тему того, каким образом мы можем выработать такие критерии.

# Понимание

<!-- Например, какой с расстановки фигурных скобок предпочтительнее использовать? Стиль, диктуемый Apple, для Objective-C и Swift использует "висящие" фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Для языков Си и Си++, которые имеют гораздо большую историю и аудиторию пользователей, число предлагаемых вариантов [гораздо больше](https://en.wikipedia.org/wiki/Indentation_style).  -->

<!-- В Objective-C стиле Apple нет пробелов между ключевыми словами и аргументами в методах, но их же стиль для Swift использует пробелы между аргументами и их метками в вызовавах функций.  -->

<!-- Очевидно, что в похожих условиях должны действовать некоторые общие закономерности, которые в той или иной степени определяют "оптимальность" используемого стиля.  -->

<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). В книге "Язык программирования Си" Б. Керниган и Д. Ритчи пишут: -->

<!-- > Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте. -->

<!-- Если считать, что разработка программного обеспечения является инженерной деятельностью очень странно наблюдать ситуацию, когда решение задачи, связанное с повышением качества разрабатываемого продукта и уменьшением затрат на его сопровождение, происходит в отсутствии каких-либо объективных критериев успешности ее решения. -->

<!-- В этой статье, не претендуя на истину в первой инстанции, я хочу предложить объективные варианты выработки таких критериев.  -->

<!-- ## Основная цель задачи форматирования стиля программного кода. -->

<!-- Итак, если программы в первую очередь должны писаться для того, чтобы люди могли их читать, то оформление программного кода является задачей такой же степени важности, как и задача разработки алгоритмов и структуры программы. Это значит, что программист должен тратить на это свое время и силы. -->


<!-- (Если, конечно, не говорить об экстремальных случаях, когда вам приходится быстро править ошибку в программе складского учета под присмотром раздраженного клиента с автоматом Калашникова – незабываемый опыт, который получили некоторые программисты в лихих 90-х.) -->

<!-- В чем же состоит основная цель этой задачи? Это задача формирования такого визуального представления и информационного наполнения текста программы, которое бы облегчило (т.е. требовало бы меньше усилий) программисту понимание этой программы и формирование соответствующей ей корректной статической и динамической ментальной модели. Или, если короче, оформление программы должно облегчать ее "чтение".  -->
<!-- <\!-- Слово "чтение" я взял в кавычки, потому что это не совсем привычное чтение, о котором мы говорим, когда мы читаем книгу. Текст программы отличается от текста в книге тем, что он гораздо более сильно структурирован, -\-> -->
<!-- Процесс понимания можно разделить на следующие подзадачи: -->
<!-- - непосредственно чтение текста; -->
<!-- - распознавание синтаксических элементов программы (различение имен переменных, функций, констант, операций над ними); -->
<!-- - понимание логической роли отдельных переменных и функций. -->
<!-- - распознование элементов рекурсивной логической структуры; -->

<!-- Прежде чем попытаться сформулировать какие-то критерии, необходимо понять, а чем, собственно говоря, мы имеем дело? Что мы собираемся оптимизировать? -->

Имея текст программы, в конечном итоге мы хотим прийти к максимально полному её пониманию. Понятно, что именно этот процесс понимания, перехода от незнания к знанию, мы и хотим облегчить (оптимизировать) с помощью оформления кода программы каким-то специальным образом.

Очевидно, что имея "текст" программы, мы будем его "читать", как мы обычно читаем тексты. Это значит, что нам надо, оптимизировать процесс чтения.
Но "чтение" программы в целом отличается от того, как мы обычно читаем прозу.

Во-первых, программы лексически и синтаксически отличаются от обычных текстов. Лексически, они составлены из ограниченного набора слов, где некоторые слова являются ключевыми словами языка программирования, а другие используются как идентификаторы для именования, например, переменных или методов. Синтаксически, программы организованны иначе, чем обычные тексты. Тексты программ отличаются широким использованием формально определенных структур, обозначаемых в тексте с помощью специальных синтаксических конструкций.[^2]

Во-вторых, существует и семантическое отличие. Восприятие обычного текста, в общем случае, состоит из двух параллельных фаз: восприятие самого текста и осмысление того, о чем он повествует. Восприятие текста программы дополнительно требует осознания операционной семантики программы, то есть того, как изменяется состояние программы в процессе её выполнения.

Эти особенности текстов программ и необходимость понимания операционной семантики приводят к тому, что чтение программ не является полностью линейно последовательным. 
В процессе чтения программы программисту приходится часто переходить от одного места в программе к другому, осуществлять поиск отдельных ее элементов.

Таким образом, нам надо оптимизировать текст программы для задачи навигации по коду и более явного отражения синтаксичесой и семантической структуры программы в ее визуальное представление.

<!-- его не всегда осуществляется в обычном порядке, когда весь текст читается слева направо и сверху вниз. Нам необходимо быстро находить и различать различные структурные элементы программы: циклы, определения и вызовы функций, объявление переменных и констант и случаи их использования. Поэтому можно также предположить, что кроме самого "чтения" нам надо оптимизировать и визуальный поиск внутри кода.  -->

<!-- Для того, чтобы понять, как и что конкретно мы можем оптимизировать в представлении текста, стоит посмотреть, а что нам известно о механизме чтения и восприятия как обычных текстов, так и текстов программ.  -->

<!-- На входе мы имеем программиста и текст программы, а на выходе хотим получить программиста, в голове которого постороенна корректная ментальная модель этой программы, и установлено соответствие между различными частями этой модели и текста программы. Процесс формирования такой модели, или процесс понимания программы, очевидно будет включать в себя процессы чтение текста программы, распознавания ее лексической и логической иерархических структур. И также очевидно, что выбранный нами стиль оформления программного кода должен по возможности оптимизировать (облегчать) выполнение всех этих задач в частности и в общем. -->



## Чтение текста

<!-- Текст программы сильно структурирован, в отличии от обычного текста. И очень часто, это не простое чтение, которое мы наблюдаем при чтении книг. При распозновании логической структуры, программисты ищут, так называемые маяки – некоторые узнаваемые атрибуты программного кода, такие как специфические переменные, управляющие конструкции, выражения. Тем не менее, психо-физиологические механизмы, задействованные в процессе чтения, остаются теми же и, к счастью для нас, хорошо изучены. -->


<!-- ### Результаты исследований -->
("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)

Когда мы читаем, наши глаза непрестанно совершают быстрые механические движения называемые _саккадами_ (_saccades_). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (_fixations_) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

<!-- При чтении мы не получаем семантическую информацию из нижележащей строки. Однако в задачах поиска слова в отрывке, читатающие иногда могут получить информацию из нижней строки. -->

Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа (2° центральной области видимости), но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области).

10% или 15% времени читающие переводят свой взгляд назад в тексте (_regressions_), чтобы повторно прочитать то, что уже было прочитано. С возрастанием трудности текста увеличивается продолжительность фиксаций и частота регрессий, а длина саккад уменьшается. 

Размер _перцептивной области_ (_области восприятия_)(perceptual span) относительно невелик: в случае алфавитных орфографий (напр. английский, французский, голландский) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки. Наблюдается некоторая вариативность в размере действительной области восприятия от фиксации к фиксации.

Область видимости, необходимая для идентификации фиксированного слова (_область идентификации_)(_identification span_) меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации.

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове.
Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определения должно ли следующее слово быть пропущено.

<!-- Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации. -->

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Существуют данные, что при разделении слов в текста на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно. 

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (_preferred viewing location_), где-то на расстоянии 1/4 длины слова от его начала. 

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове происходит ближе к предпочитаемой точке, чем когда этот промежуток оказывается за ее пределами.

Некоторые исследователи оперируют понятием _оптимальная позиция взгляда_ (_optimal viewing position_). Оптимальная позиция взгляда – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда, ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.


### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
|------------------|-----------------------------------------|----------------------------------|
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |

В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим отклонением от центра сцены, она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени).

Также при сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена.


<!-- #### Выводы -->
<!-- 1. Оптимальная длина идентификатора составляет приблизительно не более 12 букв (4 слева и 8 справа от начальной точки фиксации). При такой длине мы будем способны распозать слово за одну фиксацию и совершить точный переход к следующему слову. -->

<!-- Следущая, субоптимальная длина составляет около 20 букв. Она соответствует двум фиксациям: первая в позиции 4 буквы от начала слова, вторая, после саккады длиной 8 букв, в позиции 12 букв от начала, так что справа остается еще 8 букв. -->

<!-- 2. Пробелы имеют значения. Они помогают нам распознавать слова, предсказывая следующие из текущей позиции, и позволяют совершать более точные саккады. -->

<!-- 3. Ограничивая длину строки, мы уменьшаем эксцентриситет слов в тексте, облегая тем самым визуальный поиск и уменьшая число саккад, необходимых для возврата к началу строки. -->

<!-- 4. Для облегчения навигации при визуальном поиске, код должен быть организован в виде рекурсивной структуры логически связанных групп. -->


## Результаты исследований механизмов понимания программ

### Theories, tools and research methods in program comprehension
#### Концепции и терминология

_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста. 

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, пограмма сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные элементы кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции. 

_Правила написания программ_ (_rules of programming discourse_) 
охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

#### Модель понимания от общего к частному 
В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня. 

#### Понимание от частного к общему
Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

#### Оппортунистическая и систематические стратегии
При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.


### Роль идентификаторов
Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода. Таким образом, если некоторый стиль именования значительно  увеличивает скорость восприятия кода, это должно существенно повлиять на общее понимание программы. 

В общем случае, использование целых слов в идентификаторах приводит к лучшему восприятию программы, чем при использовании сокращений.

Также, идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.

При исследовании влияния разных видов заполнений промежутков между словами на время чтения было обнаружено, что скорость уменьшалась на 10-75% в зависимости от вида заполнителя. 

--
[^2]: Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif