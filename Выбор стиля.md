# Критерии выбора оптимального стиля оформления текста программы

_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_Стив Макконелл. "Совершенный код"_

## Вступление

_"Programs must be written for people to read, and only incidentally for machines to execute."_
_Harold Abelson, Structure and Interpretation of Computer Programs_

_“Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write.”_
_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_

Одной из важных характеристик качества разрабатываемого продукта является _удобочитаемость_ (_readability_) программного кода, которая во многом определяет степень затрат на его сопровождение и развитие.

Основным средством поддержания удобочитаемости кода обычно является установление общего свода правил форматирования  (стиля) исходного кода разрабатываемой программы. Само по себе наличие таких правил, несомненно, оказывает некоторое положительное влияние на качество кода и его удобочитаемость,так как формирует у программистов определенные привычки относительно тех языковых конструкций, которые они ожидают увидеть в тексте программы. Кроме того, необходимость следования заданным правилам вынуждает программистов внимательнее относиться к тому, что и как они пишут.

Тем не менее критерии задания отдельных конкретных правил данного стиля очень часто остаются неясными и порой не соответсвуют соответсвующим правилам в других подобных стилях.

Например, какой стиль расстановки фигурных скобок предпочтительнее использовать? Стиль, диктуемый Apple, для Objective-C и Swift использует "висящие" фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Однако не все разработчики согласны с этим выбором, и [хотели бы использовать стиль Allman](https://ericasadun.com/2015/12/28/swift-bracing/). Языки Си и Си++ имеют гораздо большую аудиторию пользователей, поэтому и число предлагаемых вариантов расстановки скобок [также больше](https://en.wikipedia.org/wiki/Indentation_style).

В книге "Язык программирования Си" Б. Керниган и Д. Ритчи пишут:
> Положение скобок не так важно, хотя существуют различные точки зрения на этот счет. Мы остановились на одном из нескольких распространенных стилей их применения. Выберите тот, который больше всего вам нравится, и строго ему следуйте.

Однако существование различных точек зрения относительно того, как расставлять фигурные скобки, и групп программистов, приверженных тому или иному стилю и готовых его отстаивать, не подтверждает тезис классиков о неважности их положения. Несоменно, в процессе разработки существуют и гораздо более важные вопросы, чем вопрос о расстановки скобок, но и этот вопрос, несмотря на свою сравнительную малость, все же заслуживат внимания программиста, поскольку является одной из тех мелких деталей, которые в совокупности определяют качество разрабатываемой программы.

<!-- На мой взгляд, такая ситуация объясняется во-первых сложностью формулировки четких и абсолютных критериев для оптимизации удобочитаемости программного кода, и, во-вторых, следующим из этого нежеланием попытаться разобраться в том, что, как и почему нужно оптимизировать. -->

Как же найти объективные критерии выбора правил в ситуации, когда субъективные часто определяются банальной привычкой конкретных программистов и приводят к противоречивым результатам?

Понятно, что эти правила должны формировать "оптимальный с точки зрения удобочитаемости" стиль текста программы. Таким образом следующий вопрос состоит в том, как "оптимизиовать" удобочитаемость.

Помимо привычек (которые, помимо всего могут быть и вредными), для всех людей существуют некоторые одинаковые механизмы восприятия визуальной информации и текстов, в частности. Объективные возможности и ограничения этих механизмов, в конечном счете определяют как много усилий потребуется нам для того, чтобы прочитать тот или иной текст.

Программы, однако, отличаются от обычных текстов. Они составлены из ограниченного набора слов и синтаксически организованны иначе, чем обычные тексты: в них широко используются формально определенные структуры, обозначаемые в тексте с помощью специальных синтаксических конструкций.[^2]

Кроме того, существует и семантическое отличие. Восприятие обычного текста, в общем случае, состоит из двух параллельных фаз: восприятие самого текста и осмысление того, о чем он повествует. Когда речь идет о коде, осмысление означает осознание синтактической и семантической структур программы, но также требует и осознания операционной семантики программы, то есть того, как изменяется состояние программы в процессе её выполнения. 

Эти особенности приводят к тому, что чтение программ не является полностью линейно последовательным. В процессе чтения программы программисту приходится часто переходить от одного места в программе к другому, осуществлять поиск отдельных элементов ее структуры. 

Таким образом, кроме кроме оптимизации непосредственно чтения, необходимо оптимизировать задачу поиска в иерархической визуальной структуре. Фактически, мы приходим к задаче формирования изображения программы, оптимальным способом отражающим ее структуру, то есть изображения, в котором отдельные, легко различаемые его области соотносятся с соотвествующими структурными элементами программы. 


Давайте посмотрим подробнее, во-первых, на то, что нам известно о механизмах чтения, и, во-вторых, на то, что нам известно о особенностях чтения и восприятия текстов программ.

## Как мы читаем обычные тексты[^1]

<!-- ### Результаты исследований -->
("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)

Когда мы читаем, наши глаза непрестанно совершают быстрые механические (т.е. не контролируеммые сознанием) движения, называемые _саккадами_ (_saccades_). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения (2° центральной области видимости) для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (_fixations_) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

<!-- При чтении мы не получаем семантическую информацию из нижележащей строки. Однако в задачах поиска слова в отрывке, читатающие иногда могут получить информацию из нижней строки. -->

Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа, но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области).

Порядка 10–15% времени читающие переводят свой взгляд назад в тексте (_regressions_), чтобы повторно прочитать то, что уже было прочитано. С возрастанием трудности текста увеличивается продолжительность фиксаций и частота регрессий, а длина саккад уменьшается. 

Размер _перцептивной области_ (_perceptual span_)(_области восприятия_) относительно невелик: в случае алфавитных орфографий (напр. английский, французский, голландский) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки. Наблюдается некоторая вариативность в размере действительной области восприятия от фиксации к фиксации.

Область видимости, необходимая для идентификации фиксированного слова (_область идентификации_)(_identification span_) меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации.

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове. Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определения должно ли следующее слово быть пропущено.

<!-- Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации. -->

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Существуют данные, что при разделении слов в текста на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно. 

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (_preferred viewing location_), где-то на расстоянии 1/4 длины слова от его начала. 

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове происходит ближе к предпочитаемой точке, чем когда этот промежуток оказывается за ее пределами.

Иногда используют понятие _оптимальная позиция взгляда_ (_optimal viewing position_). Оптимальная позиция взгляда – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.


### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
|------------------|-----------------------------------------|----------------------------------|
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |

В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим эксцентриситетом (отклонением от центра сцены), она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени). При сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена.


<!-- #### Выводы -->
<!-- 1. Оптимальная длина идентификатора составляет приблизительно не более 12 букв (4 слева и 8 справа от начальной точки фиксации). При такой длине мы будем способны распозать слово за одну фиксацию и совершить точный переход к следующему слову. -->

<!-- Следущая, субоптимальная длина составляет около 20 букв. Она соответствует двум фиксациям: первая в позиции 4 буквы от начала слова, вторая, после саккады длиной 8 букв, в позиции 12 букв от начала, так что справа остается еще 8 букв. -->

<!-- 2. Пробелы имеют значения. Они помогают нам распознавать слова, предсказывая следующие из текущей позиции, и позволяют совершать более точные саккады. -->

<!-- 3. Ограничивая длину строки, мы уменьшаем эксцентриситет слов в тексте, облегая тем самым визуальный поиск и уменьшая число саккад, необходимых для возврата к началу строки. -->

<!-- 4. Для облегчения навигации при визуальном поиске, код должен быть организован в виде рекурсивной структуры логически связанных групп. -->


## Результаты исследований механизмов понимания программ[^3]
### Концепции и терминология
_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста. 

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, пограмма сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные элементы кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции. 

_Правила написания программ_ (_rules of programming discourse_) 
охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

### Модель понимания от общего к частному 
В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня. 

### Понимание от частного к общему
Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

### Оппортунистическая и систематические стратегии
При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.

### Роль идентификаторов[^4]
Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода. Таким образом, если некоторый стиль именования значительно  увеличивает скорость восприятия кода, это должно существенно повлиять на общее понимание программы. 

В общем случае, использование целых слов в идентификаторах приводит к лучшему восприятию программы, чем при использовании сокращений.

Идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.

При исследовании влияния разных видов заполнений промежутков между словами на время чтения было обнаружено, что скорость уменьшалась на 10-75% в зависимости от вида заполнителя. 

## Обобщение результатов

### Визуальное представление

Для облегчения навигации по тексту программы и отображения различных ее частей на логическую структуру программы, необходимо соответствующим образом формировать ее визуальное представление. В идеальном случае, в программе должны быть возможным легко выделить области, относящиеся к синтаксически или семантически связанным элементам.

Например, в определении функции нам необходимо визуально разделить объявление функции, включающее её имя, возвращаемый тип, список параметров и
тело функции. Внутри тела функции необходимо разделить код инициализации начальных переменных, тело основного алгоритма, формирование и возвращение результата. В свою очередь, внутри кода инициализации нам надо разделить область типов, имен переменных и присваиваемых им значений.

Таким образом, мы разделяем области кода как по вертикали, так и по горизонтали. В первом мы случае выполняем эти разделения посредством добавления пустых строк. Во втором – мы используем выравнивание.

В общем случае, выравнивание схожих элементов в последовательности однородных строк значительно облегчает чтение и поиск. Фактически, в этом случае мы используем табличную форму представления информации. При этом в некоторых случаях имеет смысл выравнивать не по левому, а по правому краю. Например, при представлении блока строк в табличной форме, содержащих однотипные структурированные списки идентификаторов, в котором некоторые идентификаторы оканчиваются одним и тем же словом на всех строках. Или при выравнивании пар ключевое слово/значение в таких языках как С#, Objective-C, Swift.

В принципе, не обязательно формировать вертикальную линию разделения между областями кода. Например, в случае последовательности строк, каждая из которых содержит инициализацию некоторой переменной, то есть имеет вид: имя переменной, оператор присваивания, присваиваемое значение. При этом такого расположения этих строк, когда длина имен переменных медленно возрастает от первой строки к последней (и эти имена выровнены слева), может быть достаточным для четкого визуального разделения групп имен переменных и их значений.

Надо стремиться к тому, чтобы основная масса кода была сконцентрированна в области первых 60 символов, и длина строки в общем случае не превышала 80 символов.

Это ограничение способствует формированию сбалансированных двумерных визуальных структур, о которых мы говорили выше, и облегчает чтение, за счет облегчения возврата к началу строки.

``` 
//
try tempCoordinator.replacePersistentStore(at: tempStoreUrl, destinationOptions: nil, withPersistentStoreFrom: storeUrl, sourceOptions: nil, ofType: store.type)

//
try tempCoordinator.replacePersistentStore (at: tempStoreUrl,
                                            destinationOptions: nil,
                                            withPersistentStoreFrom: storeUrl,
                                            sourceOptions: nil,
                                            ofType: store.type)
//
try tempCoordinator.replacePersistentStore (at:                      tempStoreUrl,
                                            destinationOptions:      nil,
                                            withPersistentStoreFrom: storeUrl,
                                            sourceOptions:           nil,
                                            ofType:                  store.type)
//
try tempCoordinator.replacePersistentStore (at: tempStoreUrl,
                            destinationOptions: nil,
                       withPersistentStoreFrom: storeUrl,
                                 sourceOptions: nil,
                                        ofType: store.type)


```

### Идентификаторы

Идентификаторы играют важнейшую роль для обеспечения удобочитаемости программного кода. Они занимают его большую часть и часто играют роль маяков, позволяющих идентифицировать характерные структурные части программы. Основные требования к идентификаторам – это их краткость и выразительность. Чем идентификатор короче, тем он легче для чтения, поиска и запоминания. Кроме того, использование коротких имен приводит к меньшему эксцентриситету кода (более коротким строкам), что облегчает чтение и поиск. Требование выразительности означает, что в области контекста использования, идентификатор должен позволять однозначно определять роль обозначаемого им элемента программы. 

Требования краткости и выразительности могут очевидным образом конфликтовать друг с другом, поскольку выразительность может требовать использования более длинных имен. Поэтому имеет смысл сделать оценку для допустимой рекомендованной длины идентитификатора. В качестве такой оценки можно использовать длину в 14 символов, как максимальную длину коротких идентификаторов. Это число немного больше средней области распознавания, но меньше области восприятия текста, и мы рассчитываем на то, что распознование такого слова не потребует более 1-2 фиксаций. Следующий приемлимый порог – это длина порядка 22 символов (предыдущая длина плюс 8 символов для дополнительной саккады). При этом мы рассчитываем, что для распознавания этого имени не потребуется более 2-3 фиксаций. 

На практике приходится использовать имена, длины которых выходят за предлагаемые пределы. Например, когда имя включают в себя некоторое стандартное именование группы, к которой относится данный элемент, как в `PreferencesViewController`. В этом случае лучше значимую, уникальную часть имени располагать в начале слова. При этом мы рассчитываем, что мы сможем распознать уникальную часть имени уже при первой фиксации, и в то же время нам не потребуется больших усилий для распознания "стандартного дополнения". 

В общем случае, каждый случай использования длинных идентификаторов (> 12-14 символов) должен рассматриваться как вынужденный компромисс. 

### Пробелы

Пробелы важны. Использование любого другого разделителя требует больший усилий при чтении. Поэтому, например, имеет смысл разделять пробелом имя функции и список ее параметров/аргументов, например, в случае, если их совокупная длина превышает размер области распознавания.

Кроме того, мы используем пробелы при формировании визуальной структуры, для разделения различных элементов синтаксической структуры программы.

```
// При отсутствии пробела первый аргумент сливается с именем функции,
// что затрудняет чтение. Кроме того, нарушается визуальная структура: 
// первый аргумент связан с этим именем сильнее, чем со вторым аргументом
// в списке аргументов.

result = someFunction(firstArgument, secondArgument);

result = someFunction (firstArgument, secondArgument);

```


### Расстановка фигурных скобок.

На сегодняшний день в языках с Си-подобным синтаксисом существуют два основных способа расстановки фигурных скобок: One Truce Brace Style (1TBS) и Allman. Остальные [известные варианты](https://en.wikipedia.org/wiki/Indentation_style) либо являются их вариациями, либо выглядят достаточно экзотически и, соответвенно, популярностью не пользуются.

В 1TBS открывающая фигурная скобка располагается в конце строки, содержащей окончание соответствующего синтаксического элемента, с которым она связана. В стиле Allman, эта скобка располагается на следующей линии с тем же отступом, как и начало связанного элемента.

В общем случае стиль Allman предпочтательнее, поскольку в нем открывающая и закрывающая скобки выровнены по вертикали. Это значительно облегчает поиск, например, парной открывающей скобки, поскольку требует лишь вертикального перемещения глаз. При этом на пути следования взгляда от одной скобки к другой, как правило, нет никакого текста, и поиск фактически происходит до первого символа. В 1TBS поиск осуществляется в широком секторе, причем взгляд проходит через текст, который надо анализировать, и который часто содержит вложенные пары фигурных скобок, что также может затруднять обнаружение нужной нам пары. 

Кроме того, поскольку в стиле Allman скобки располагаются на отдельных строках, блок кода внутри них визуально явно отделен от заголовка конструкции, что лучше сответствует структуре этой конструкции. В 1TBS такого явного разделения нет, особенно в случае, когда предшествующая часть занимает несколько строк.

Тем не менее, есть случаи, когда 1TBS может оказаться предпочтительнее, чем Allman. Например, в случае короткого условия в операторе `if`, когда код внутри скобок содержит 1-3 строки. В такой ситуации использование стиля Allman может приводить к развалу визуальной структуры кода, так что заголовок конструкции, оказывается недостаточно связанным с кодом внутри скобок по сравнению с окружающими элементами.

Таким образом, выбор того или иного способа расстановки скобок должен осуществляться программистом в каждом конкретном случае, для того чтобы сформировать оптимальное визуальное представление конкретной части программного кода.

<!-- 6. Использование символов табуляции. -->
<!-- Единственная причина использования символов табуляции – это "оптимизация" процедуры редактирования. -->
<!-- Вместе с тем, они добавляют в текст программы скрытую структуру, которая часто приводит к разрушению визуального преставления кода при переносе из одного окружения в другое. Например, вы можете быть счастливы установив ширину символа табуляции в четыре пробела на своем компьютере, но на github ваш код скорее всего будет иметь некорректные отступы. Его визуальная структура будет нарушена.  -->


<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). -->

## Резюме

<!-- Подводя итоги, можно сказать, что основными критериями выбора правил оформления программного кода должно быть повышение удобочитаемости текста программы и формирование ее визуального представления таким образом, чтобы оно максимально возможным образом отражало синтактическую и семантическую структуру программы.  -->
<!-- При этом удобочитаемость программы улучшается при разделении идентификаторов пробелами, и, как правило, ухудшается при увеличении их длины.  -->

<!-- Структурирование текста программы связано с формированием двумерной визуальной структуры, в которой синтаксически и семантически связанные элементы программы образуют геометрически сбалансированные области. Иными словами мы отражаем структуру программу в некоторое изображение. Для оценки качества этого представления можно попытаться оценить его отодвинувшись от экрана и разфокусировав взгляд.  -->



--
[^1]: [Eye Movements in Reading and Information Processing: 20 Years of Research. Keith Rayner – University of Massachusetts at Amherst](https://www.semanticscholar.org/paper/Eye-movements-in-reading-and-information-20-years-Rayner/87c8a7be8d5e2e2209e766c3e28a3e8ee5babb64)
[^2]: [Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif](https://dl.acm.org/doi/10.5555/2820282.2820320)
[^3]: [Theories, tools and research methods in program comprehension: Past, Present and Future. Margaret-Anne Storey](http://www.ptidej.net/courses/inf6306/fall10/slides/course8/Storey06-TheoriesMethodsToolsProgramComprehension.pdf)
[^4]: [An Eye Tracking Study on camelCase and under_score Identifier Styles. Bonita Sharif and Jonathan I. Maletic – Department of Computer Science Kent State University](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf)
[^5]: [Achieving Software Quality through Source Code Readability, Phillip Relf](https://www.researchgate.net/publication/238443707_Achieving_Software_Quality_through_Source_Code_Readability)
[^6]: [Relating Identifier Naming Flaws and Code Quality: An Empirical Study. Simon Butler](https://ieeexplore.ieee.org/document/5328661)