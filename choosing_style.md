

# Выбор стиля. Оптимизация визуального представления программы.

_Грубо говоря, очевидно, что некоторые виды форматирования лучше других._
_— Стив Макконелл, Совершенный код._

_Рискуя вызвать резкое неудовольствие со стороны моих коллег, я применяю принципы, в которые верю с какой-то безрассудной односторонностью. Частично я это делаю в силу того, что в отдельных случаях полезно изложить свою точку зрения с голой простотой и тем самым предоставить дальнейшую шлифовку своей концепции последующим ударам и контрударам критики._

_— Рудольф Арнхейм, Искусство и визуальное восприятие._

## Вступление

_Компьютерный язык — это не просто способ заставить компьютер производить вычисления, а новое формальное средство выражения методологических идей. Таким образом, программы должны писаться для того, чтобы их читали люди, и лишь во вторую очередь для выполнения машиной._

_— Харольд Абельсон, Джеральд Д. Сассман, Структура и интерпретация компьютерных программ._



_Соотношение времени чтения и написания кода превышает 10:1. … Из-за столь высокого соотношения наш код должен легко читаться, даже если это затрудняет его написание._

_— Роберт Мартин, Чистый код: создание, анализ и рефакторинг._



<!--_ _Programs must be written for people to read, and only incidentally for machines to execute._-->
<!--_-- Harold Abelson, Structure and Interpretation of Computer Programs_-->

<!--_Indeed, the ratio of time spent reading versus writing is well over 10 to 1. We are constantly reading old code as part of the effort to write new code. ...[Therefore,] making it easy to read makes it easier to write._-->
<!--_― Robert C. Martin, Clean Code: A Handbook of Agile Software Craftsmanship_-->

<!-- Программы пишутся для людей. И не только для тех, кто будет использовать эти программы, но и для тех, кто впоследствии будет их сопровождать и дорабатывать. -->
<!-- То, насколько легко или сложно это будет делать, зависит, в частности, и от того, насколько удобочитаемым и понятным будет их исходный код.  -->

<!-- _Удобочитаемость_ (_readability_) программного кода – одна из важных характеристик качества разрабатываемого продукта, которая во многом определяет степень затрат на его сопровождение и развитие.  -->

<!-- Таким образом, перед разработчиком стоит не только задача разработки программы как сложно структурированной совокупности инструкций и организации этой совокупности   -->

<!--Программа существует не только как выполняемый процесс, но и в виде развиваемого и сопровождаемого исходного кода. И для каждой из этих двух ипостасей существуют свои пользователи: конечные пользователи программы и её разработчики. Наверно, не будет ошибкой сказать, что удовлетворенность разработчиков как пользователей во многом определяет насколько довольны оказываются и конечные пользователи.-->

<!--Удовлетворенность разработчиков определяется тем, насколько легко дается им сопровождение и развитие программы, и одним из решающих факторов, определяющих степень этой легкости, несомненно, является _удобочитаемость_ текста программы.-->

Наверно, никому не надо доказывать то, что _легкость восприятия_ текста программы является одним из решающих факторов, определяющих успешность её сопровождения и развития. 

Обычно, когда говорят о _легкости восприятия_ программы используют термин _удобочитаемость_. Строго говоря, это не совсем одно и то же, поскольку, как будет показано дальше, процесс восприятия программы это больше, чем просто чтение.  Тем не менее, поскольку речь идет о тексте, и термин _удобочитаемость_ можно считать достаточно устоявшимся, я буду использовать его в более широком смысле как _легкость восприятия_.

Для поддержания удобочитаемости кода в процессе разработки программы обычно договариваются о некотором общем своде правил форматирования (стиля) исходного кода. Уже само по себе наличие таких правил, несомненно, оказывает положительное влияние на его качество и  удобочитаемость, так как формирует у программистов определенные привычки относительно тех языковых конструкций, которые они ожидают увидеть в тексте программы. Необходимость следования заданным правилам играет дисциплинирующую роль, вынуждая обращать внимание на то, как выглядит создаваемый ими код, и предупреждая возможные конфликты, вызванные личными предпочтениями отдельных разработчиков.

Тем не менее, сами правила часто вызывают вопросы, поскольку критерии их выбора неясны, и сами правила нередко противоречат аналогичным правилам в других подобных стилях. 

<!--Например, какой стиль расстановки фигурных скобок предпочтительнее использовать?-->

<!--Стиль, диктуемый Apple, для Objective-C и Swift использует «висящие» фигурные скобки, когда открывающая скобка находится на той же строке, что и управляющая конструкция или объявление метода/функции, с которыми она связана. Однако [не все разработчики согласны с этим выбором, а предпочли бы использовать стиль Allman](https://ericasadun.com/2015/12/28/swift-bracing/), в котором открывающая скобка расположена на новой строке. Языки Си и Си++ имеют гораздо большую аудиторию пользователей, чем Objective-C и Swift, а поэтому и число предлагаемых вариантов расстановки скобок [больше](https://en.wikipedia.org/wiki/Indentation_style).-->

<!--_«Положение скобок не так важно…»_ пишут Б. Керниган и Д. Ритчи в книге «Язык программирования Си». Да, конечно, в процессе разработки существуют и гораздо более важные вопросы, чем вопрос о расстановки скобок. Но, как известно, Бог в мелочах, и этот вопрос, несмотря на свою сравнительную малость, все же заслуживает внимания, поскольку является одной из тех деталей, которые складываясь, как элементы мозаики, формируют окончательный вид программы и определяют в результате ее удобочитаемость.-->

Правила задают конкретные детали оформления кода в целях поддержания удобочитаемости, но при этом отсутствует понимание того, как эти правила помогают ее достичь. В результате часто приходится слышать высказывания о том, что использование того или иного стиля это всего лишь «дело вкуса». Решение инженерной задачи формирования оптимального с точки зрения удобочитаемости текста программы, подменяется слепому следованию формальным и часто произвольно выбранным правилам.

Механизмы восприятия и обработки человеком визуальной информации (и текстов, в частности) обладают определенными возможностями и имеют некоторые ограничения, которые в конечном счете определяют то, как много усилий потребуется для корректного и полного восприятия представленной информации. Следовательно, _удобочитаемость_ текста определяется тем, насколько его визуальное представление учитывает специфические особенности этих общих механизмов восприятия, и поэтому является _объективной характеристикой_ качества визуального представления текста. Это означает, что удобочитаемость не должна зависить от субъективных предпочтений и привычек отдельного индивидуума, а имеет всеобщий характер для всех людей в нормальном психическом и физическом состоянии.

<!-- Учитывая множество различных стилей, можно предположить, что как минимум некоторые из них не учитывают особенности механизмов восприятия, и, вероятно, являются следствием интуиции и привычек их составителей или воспроизводят правила из «авторитетного» источника. <\!-- В этом смысле удобочитаемость оказывается субъективным параметром. -\-> -->

Программы отличаются от обычных текстов. Программы составлены из ограниченного набора слов и организованны иначе, чем обычные тексты: в них широко используются формально определенные структуры, обозначаемые в тексте с помощью специальных синтаксических конструкций. Кроме того, существует и семантическое отличие. Восприятие обычного текста, в общем случае, состоит из двух параллельных фаз: восприятие самого текста и осмысление того, о чем он повествует. Когда речь идет о коде, осмысление означает осознание синтактической и семантической структур программы, но также включает и осознание операционной семантики программы, то есть того, как изменяется состояние программы в процессе её выполнения.[^2] Процесс чтения программы также отличается от чтения прозы. Кроме непосредственно чтения текста,  программисту приходится также _сканировать_ текст с целью восприятия основных элементов верхнего уровня её иерархической структуры, осуществлять поиск отдельных идентификаторов, переходить от одного места в программе к другому, возможно расположенному в другом файле.

Легкость восприятия визуального представления структуры программы оказывается не менее важной, чем легкость восприятия ее текста как такового.

Таким образом, кроме кроме оптимизации непосредственно чтения, необходимо оптимизировать задачу поиска в иерархической логической структуре. Фактически, мы приходим к задаче формирования _визуального представления_ программы, оптимальным способом отражающим ее структуру, то есть _изображения_, в котором отдельные, легко различаемые его области соотносятся со структурными элементами программы.

Давайте посмотрим подробнее, на то, что нам известно о механизмах восприятия зрительной информации, чтения текстов в целом и чтении и восприятии текстов программ.

## Особенности зрения человека [^9]

[Поле зрения](https://ru.wikipedia.org/wiki/Поле_зрения) человека достаточно велико: 55° вверх, 60° вниз, 90° наружу (то есть суммарное поле зрения двумя глазами — 180°) и 60° внутрь. Однако внутри этого поля острота зрения и цветовосприятие распределены неравномерно: острота зрения порядка 1' достигается в области _фовеа_, формирующей ~2° центрального (_фовеального_) зрения, но она не так хороша в _парафовеальной_ области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии.

Подобным же образом от центра к краю падает и способность различать цвета, причем это изменение различно для разных цветовых компонент. Можно сказать, что, двигаясь от центра человеческой сетчатки к периферии, мы как бы оказываемся на более ранних этапах эволюции, переходя от наиболее высоко организованных структур к примитивному глазу, который различает лишь простое движение теней.

###### Поле зрения правого глаза человека. Оранжевое пятно — место проекции слепого пятна глазного дна. ([оригинал](https://ru.wikipedia.org/wiki/%D0%9F%D0%BE%D0%BB%D0%B5_%D0%B7%D1%80%D0%B5%D0%BD%D0%B8%D1%8F#/media/%D0%A4%D0%B0%D0%B9%D0%BB:Goldmann_visual_field_record_sheet.svg))

<img src="1920px-Goldmann_visual_field_record_sheet.svg.png" height="350"/>

<!-- Свет пройдя сквозь роговицу, хрусталик и стекловидное тело попадает на сетчатку, где под сетью капилляров и нейронов расположены фоторецепторы: колбочки и палочки.   -->
<!-- Всего на зрительной сетчатке располагаются порядка 7 млн. колбочек и более 120 млн. палочек. Колбочки являются аппаратом цветового зрения, в то время как палочки, обладающие гораздо большей чувствительностью, формируют сумеречное, черно-белое видение.  -->

<!-- По чувствительности к свету с различными длинами волн различают три вида колбочек. Колбочки S-типа чувствительны в фиолетово-синей (S от англ. Short — коротковолновый спектр), M-типа — в зелено-желтой (M от англ. Medium — средневолновый), и L-типа — в желто-красной (L от англ. Long — длинноволновый) частях спектра. -->

<!-- В области желтого пятна, которое находится в визуальном центре сетчатки, концентрация колбочек масимальна. Угловой размер желтого пятна составляет приблизительно 6—7°. Внутри желтого пятна находится так называемая центральная ямка (fovea centralis) — участок сетчатки с наибольшей разрешающей способностью. Диаметр центральной ямки около 0,4 мм, т. е. около 1,3°.  -->

<!-- Сетчатка делится по вертикали на две части; от наружных отделов сетчатки волокна идут к той же стороне затылочной области мозга в то время как волокна от внутренней, назальной стороны сетчатки перекрещиваются сразу позади глаз — в chiasma opticum (зрительный перекрест) — и направляются к затылочной области противоположного полушария (рис. 5, 5).[^7] -->

<!-- Края человеческой сетчатки не дают даже зрительного ощущения; когда они стимулируются движущимся объектом, они вызывают только рефлекторный поворот глаз к этому объекту, после чего глаз воспринимает его наиболее высокоорганизованной частью сетчатки.[^7] -->

В современной нейропсихологии существует представлении о двух различных зрительных системах: так называемом _амбьентном_ зрении (от фр. ambiance = окружение) и о _фокальном_ зрении. В то время как первая, эволюционно более древняя, ответственна за динамическую пространственную локализацию, вторая занимается идентификацией объектов.

###### Сравнительые признаки фокальной и амбьентной систем

| Зрительная система           | Фокальная         | Амбьентная             |
|------------------------------|-------------------|------------------------|
| Структуры коры               | Вентральный поток | Дорзальный поток       |
| Функция                      | Что               | Где/Как                |
| Включенность в движение      | Меньше            | Больше                 |
| Осознание/Память             | Больше            | Меньше или отсутствует |
| Временные свойства           | Медленая          | Быстрая                |
| Чувствительность к освещению | Высокая           | Низкая                 |
| Пространственное разрешение  | Высокое           | Низкое                 |

Объекты, представляющие собой источник нужных сведений, распределены далеко неравномерно. Обычно они локализованы в небольших участках поля зрения. При этом с помощью амбьентного зрения обнаруживается потенциально интересный объект или элемент объекта, а при помощи фокального зрения направленного на объект, эти сведения воспринимаются и анализируются более детально. Сталкиваясь с новой ситуацией или с новым объектом, мы, как правило, сначала смотрим «широким полем» и лишь затем концентрируем наше внимание на деталях.

Обследование окружения и выбор объектов для детальной обработки осуществляется с помощью движений головы и тела, на которые накладывается тонкий узор движений глаз.  Наиболее известной их разновидностью являются _саккады_ — чрезвычайно быстрые (~500°/сек) скачки баллистического типа, меняющие положение глаз в орбите и позволяющие выделять фрагменты сцены для последующей _фиксации_.

###### Репродукция картины И. Е. Репина и запись движений глаз испытуемого.[^11]

<img src="Yarbus_ne_zhdaly.jpg" height="320"/>


Начало исследованиям соотношения амбьентной (глобальной) и фокальной (локальной) зрительной обработки было положено в экспериментах Дэвида Навона в 1977. Он предъявлял испытуемым большие буквы, состоявшие из маленьких букв. Некоторые из этих составных стимулов были «однородными» — глобальная форма и локальные элементы представляли собой одну и ту же букву. Другие были «неоднородными» — глобальная и локальные буквы были разными (скажем, «Е» и «S»). Испытуемые должны были как можно быстрее идентифицировать глобальную или локальную букву.

<img src="Velichkovskiy_FF.png" height="170"/>

Оказалось, что при настройке на глобальную форму она идентифицируется быстро и без всякой интерференции со стороны совпадающих или несовпадающих букв локального уровня. При настройке на идентификацию деталей картина была иной. Во-первых, ответы были более медленными. Во-вторых, в случае неоднородных стимулов ответы дополнительно замедлялись и становились менее точными. Очевидно, настраиваясь на детальную обработку, мы не всегда можем игнорировать глобальную информацию.

В результате исследований отношения глобальной и локальной обработки, тестируемые с помощью супербукв Навона, была обнаружена возможно дифференциальная роль задних отделов левого и правого полушарий. При этом левое полушарие оказалось скорее регулятором настройки на детали, а правое — на глобальные очертания. Чрезвычайно интересным оказалось влияние эмоций: отрицательные эмоции, в отличие от положительных, усиливали установку на восприятие деталей.

Интересной особенностью нашего зрения является способность воспринимать группу объектов как единое целое. Так на изображении ниже мы видим собаку, а не просто набор хаотических пятен:

![](dog.jpg)

А здесь мы ясно различаем квадрат и круг[^10]:

![](Arnheim_1.png)



Есть множество объяснений возникновения подобных иллюзий. С точки зрения когнитивной биономии потребность видеть формы, грани и движения (а также лица) была продиктована необходимостью в выживании. Таким образом, даже при отсутствии реальных линий или форм наша сенсорно-когнитивная система использовала частичную информацию, чтобы создать эти формы в попытке сделать понятным внешне хаотический мир.

Посмотрите на рисунок ниже, и вы увидите как с течением времени ориентация треугольников меняется с одного направления на другое, третье. 

<img src="triangles.png" height="200"/>

Наш мысленный взгляд постоянно ищет альтернативную перцептивную организацию. При этом попытки увидеть эти треугольники как направленные в разные стороны требуют больших ментальных усилий, возможны только для небольшого их числа и оказываются менее устойчивыми.

Первыми это явление стали изучать гештальтпсихологи. Так, они сформулировали основной закон зрительного восприятия, согласно которому _любая стимулирующая модель воспринимается таким образом, что результирующая структура будет, насколько это позволяют данные условия, наиболее простой_. Поэтому мы воспринимаем квадрат именно так, как он изображен слева, а не каким-то другим образом:[^10]

![](Arnheim_2.png)

Гештальтпсихологи также сформулировали 6 принципов перцептивной организации. В соответствии с этими принципами _объекты, которые_

- _расположены близко друг к другу («закон близости»),_
- _имеют похожие яркостные и цветовые характеристики («сходства»),_
- _ограничивают небольшую, замкнутую («замкнутости»)_
- _и симметричную область («симметрии»),_
- _естественно продолжают друг друга («хорошего продолжения»),_
- _движутся примерно с равной скоростью в одном направлении («общей судьбы»),_

_скорее будут восприняты как единое целое, или фигура, а не как разрозненные элементы среды, или фон_.

На иллюстрациях ниже[^10] показаны примеры сходства по близости, цвету и размеру.

<img src="Arnheim_3.png" height="200"/>

В случае конкуренции нескольких факторов перцептивной организации преимущество, как правило, отдается фактору _близости_, а затем фактору _сходства по окраске_, _ориентации_ или _размеру_.

Учет этих принципов оказывается важным в случае перцептивного поиска или восприятия, поскольку, _если информация организована в соответсвии с этими принципами, решение поставленной задачи требует меньших усилий за счет того, что перцептивное поле подвергается группировке, и на образовавшиеся группы элементов последовательно выделяется всё меньшая доля общих ресурсов_. Распределение ресурсов внутри каждой группы оказывается примерно равномерным.

Задачи зрительного поиска обычно затрудняются при добавлении иррелевантных объектов — дистракторов. Однако _в случае, когда дистракторы образуют визуально компактные группы, позволяющие игнорировать их как целое, их добавление наоборот может значительно облегчить поиск_.

Левое и правое полушарие обрабатывают сенсорную информацию от правого и левого поля зрения соответственно. Из-за асимметрии в том, за что отвечают правое и левое полушарие, можно ожидать, что подобно асимметрии между левой и правой рукой существует некоторая асимметрия в том, как мы воспринимаем левое и правое визуальные поля.

Действительно, в сценическом искусстве известно, что существует разница между левой и правой половиной сцены: как только подымается занавес в начале акта, зрители начинают смотреть в левую сторону сцены. Левая сторона сцены считается более сильной. В группе из двух или трех актеров тот, кто стоит с левой стороны, будет в данной сцене доминировать. Аналогично в изобразительном искусстве известно, что  зритель воспринимает рисунок, как если бы он свое внимание сосредоточил на левой стороне рисунка. Субъективно он отождествляет себя с левой стороной, и все, что появляется в этой части картины, имеет большое значение. Таким образом, кроме естественной точки равновесия в центре визуальной сцены, формируется дополнительный центр в ее левой части[^10].

<!-- Известен случай, когда двое пациентов знаменитого советского офтальмолога Авербаха М.И., адвокатов по профессии, вследствие глазных заболеваний имели противоположные нарушения зрения: у первого страдало центральное зрение, а у второго — периферическое (поле зрения его было сужено почти до точки фиксации). В здании судебного учреждения, где они работали, был длинный темный коридор, и оба пациента каждый день проходили по нему. Первый из них, совершенно не способный прочесть ни одной строчки, свободно двигался по коридору, не нуждаясь в посторонней помощи. Второй, легко читавший мельчайший газетный шрифт, войдя в коридор, беспомощно останавливался и ждал, пока первый не проводит его в зал заседаний -->

<!-- Познавательные способности нашего сознания (а художественное творчество является одной из них) тщательно отыскивают порядок. Но в то время как наука извлекает из многообразия явлений закономерности порядка, искусство использует явление для того, чтобы показать порядок в разнообразии.  -->

<!-- Искусство программиста заключается в том, чтобы, организовав визуальный порядок в разнообразии, облегчить возможность выявления его закономерностей. -->

<!-- Форма кода -->

<!-- Формирование визуального представления (изображения) кода программы это часть ремесла программиста, которая находится на грани искусства. -->
<!-- Энтропия кода и энтропия изображения (визуального представления) кода -->
<!-- Большое видится на расстоянии, лицом к лицу лица не увидать. -->
<!-- Типографика -->
<!-- Разделение полушарий -->
<!-- Арнхейм -->
<!-- психология зрительного восприятия -->
<!-- Ассиметрия левой и правой стороны -->


## Как мы читаем обычные тексты[^1]

<!-- ### Результаты исследований -->
<!--("Eye Movements in Reading and Information Processing: 20 Years of Research by Keith Rayner – University of Massachusetts at Amherst)-->

Когда мы читаем, наши глаза непрестанно совершают быстрые механические (т.е. не контролируеммые сознанием) движения, называемые _саккадами_ (_saccades_). В среднем их длина составляет 7-8 символов. В это время мы не получаем новой информации. Основная функция саккад закючается в перемещении новой области текста в область фовеального зрения (2° центральной области видимости) для детального анализа, потому что чтение в области парафовеального или периферического зрения сильно затруднено или невозможно.

###### Типичная картина движений глаз при чтении[^9]

<img src="Velichkovskiy_reading.png" height="170"/>


Между саккадами наши глаза остаются относительно неподвижными на время _фиксаций_ (_fixations_) (около 200 – 300 мс). В течение этого периода мы распознаем видимую часть текста и планируем, куда совершить следующий переход.

<!-- При чтении мы не получаем семантическую информацию из нижележащей строки. Однако в задачах поиска слова в отрывке, читатающие иногда могут получить информацию из нижней строки. -->

<!-- Когда глаза останавливаются на какой-то заданной точке вдоль линии текста, только 4-5 символов непосредственно около точки фиксации видны со 100% четкостью. Острота зрения очень высока в области фовеа, но не так хороша в парафовеальной области (которая покрывает 5° в сторону от точки фиксации) и еще хуже на периферии (которая находится за границами парафовеальной области). -->

Порядка 10–15% времени читающие переводят свой взгляд назад в тексте (_regressions_), чтобы повторно прочитать то, что уже было прочитано. С возрастанием трудности текста увеличивается продолжительность фиксаций и частота регрессий, а длина саккад уменьшается.

Размер _области восприятия_ (_perceptual span_) относительно невелик: в случае алфавитных орфографий (напр. для европейских языков) эта область начинается от начала фиксированного слова, но не более, чем на 3-4 буквы слева от точки фиксации, и распространяется приблизительно на 14-15 размеров букв вправо от этой точки (суммарно 17-19 букв).

_Область идентификации_ (_identification span_), то есть область видимости, необходимая для идентификации фиксированного слова меньше, чем область восприятия и, как правило, не превышает 7-8 размеров букв справа от фиксации (суммарно порядка 10-12 букв).

Доступность первых 3 буквы слова во время предыдущей фиксации приводит к снижению времени фиксации на этом слове. Некоторые исследователи также показали, что информация о буквах справа от фиксации может быть использована для определения должно ли следующее слово быть пропущено.

<!-- Информация из области парафовеального зрения также используется для определения длины текущего слова, которая, в свою очередь, используется для определения места следующей точки фиксации. -->

Большинство исследователей полагают, что информация о границах слова (обеспечиваемая промежутками между словами) является основным фактором в определении места следующей фиксации. Длина саккады зависит как от длины фиксированного слова, так и от длины слова, следующего за ним.

В большинстве случаев чтение замедляется (в среднем на 30%) при отстутствии информации о промежутках (между словами). Отсутствие такой информации приводит к нарушению как процессов идентификации слова, так и перемещения взгляда.

Существуют данные, показывающие, что при разделении слов в тексте на тайском языке (для людей, которые никогда прежде не читали такие тексты с разделением слов пробелами), чтение осуществлялось более эффективно.

Информация о длине слова также играет явную роль в определении того, где должна располагаться точка фиксации. Хотя присутствует некоторая вариативность в том, где внутри слова останавливается взгляд, как правило первая фиксация на слове осуществляется в _предпочитаемой точке взгляда_ (_preferred viewing location_), где-то на расстоянии 1/4 длины слова от его начала.

Когда промежуток между текущим и следующим словами попадает в парафовеальную область, первая фиксация на следующем слове происходит ближе к предпочитаемой точке, чем когда этот промежуток оказывается за ее пределами.

_Оптимальная позиция взгляда_ (_optimal viewing position_) – это такая позиция, в которой время распознавания слова минимально. Эта позиция сдвинута чуть правее от предпочитаемой позиции взгляда ближе к середине слова.

Когда фиксация осуществляется в позиции, отличной от оптимальной, то для изолированных слов наблюдаются два основных эффекта: чем дальше точка фиксации от оптимальной позиции, тем больше вероятность рефиксации на этом слове. Во-вторых, присутствует эффект увеличения стоимости обработки: для каждой буквы, на которую фиксация отклоняется от оптимальной позиции, стоимость обработки увеличивается примерно на 20 мс. Для слов внутри текста, однако, последний эффект практически отсутствует.

Несмотря на то, что в среднем позиция первой фиксации на слове лежит между началом слова и его серединой, эта позиция может меняться в зависимости от расстояния до предыдущей точки фиксации. Например, если расстояние до целевого слова большое (8-10 размеров букв), положение следующей фиксации сдвигается влево. Соответственно, если расстояние мало (2-3 размера букв), положение фиксации сдвигается вправо.

Позиция первой (и возможно единственной) фиксации на слове лежит между началом и серединой слова для слов длиной 4-10 буквы. Однако для более длинных слов наблюдается тенденция делать первую фиксацию ближе к началу слова и затем делать вторую ближе к концу слова.

Информационная плотность (или морфологическая структура) слова влияет на продолжительность фиксаций на каждой части слова. Например, было замечено, что если слово было возможно распознать по первым 6 буквам (слова были в среднем длиной около 12 букв), то, в общем случае, после первой фиксации в первой половине слова, взгляд переходил к следующему слову; в случаях, когда фиксация во второй части все же осуществлялась, то она была очень короткой. Однако в случае, когда слово могло быть распознано только по его окончанию, первая фиксация была короткой, а вторая, на конце слова, более длинной.

###### Таблица 1. Приблизительные средние значения продолжительности фиксаций и длин саккад при чтении и поиске

| Задача           | Средняя продолжительность фиксации (мс) | Средний размер саккады (градусы) |
|------------------|-----------------------------------------|----------------------------------|
| Чтение           | 225                                     | 2 (~ 8 букв)                     |
| Чтение вслух     | 275                                     | 1.5 (~ 6 букв)                   |
| Визуальный поиск | 275                                     | 3                                |
| Восприятие сцен  | 330                                     | 4                                |
| Чтение нот       | 375                                     | 1                                |
| Печать           | 400                                     | 1 (~ 4 буквы)                    |



В отношении визуального поиска было установлено, что когда цель находилась в области с небольшим _эксцентриситетом_ (отклонением от центра сцены), она обнаруживалась точно, с использованием одной саккады; когда цель располагалась ближе к периферии, наблюдались саккады в ложных направлениях (до 40% по времени). _При сложных задачах поиска глаза изначально направлялись к центру сцены и затем к центрам рекурсивно меньших групп объектов до тех пор, пока цель не была найдена_.



## Результаты исследований механизмов понимания программ[^3]

### Концепции и терминология

_Ментальная модель_ описывает мысленное представление разработчика о программе, которую необходимо понять, в то время как _когнитивнная модель_ описывает познавательные процессы и временные информационные структуры, которые используются для формирования ментальной модели в сознании программиста.

_Планы программирования_ (_programming plans_) – это общие фрагменты кода, представляющие типичные сценарии в программировании. Например, программа сортировки будет содержать цикл для сравнения двух чисел в каждой итерации. Планы программирования также часто называют _клише_ и _схемы_. _Делокализованные планы_ (_delocalized plans_) возникают, когда план программирования реализуется в различных частях программы. Наличие делокализованных планов усложняет понимание программ.

_Маяками_ (_beacons_) называют узнаваемые, характерные элементы кода, которые служат признаками присутствия в нем некоторых структур. Например, имя процедуры может указывать на реализацию определенной функции.

_Правила написания программ_ (_rules of programming discourse_) охватывают принятые соглашения, такие как стандарты кодирования и реализации алгоритмов. Эти правила формируют определенные ожидания в сознании программиста.

### Модель понимания от общего к частному

В этой модели предполагается, что процесс понимания программы происходит от общего к частному, когда воссоздание знания о прикладной области программы отображается затем на код программы. Процесс начинается с формулировки гипотезы об общем характере программы. Первичная гипотеза затем уточняется иерархическим способом путем формирования вспомогательных гипотез. Вспомогательные гипотезы уточняются и оцениваются в первую очередь по глубине. Верификация (или отклонение) гипотез сильно зависит от отсутствия или наличия маяков.

Процесс понимания программы от общего к частному используется, когда код программы или его вид знаком. При этом опытные программисты используют маяки, планы программирования и правила написания программ для декомпозиции целей и планов в планы более низкого уровня.

### Понимание от частного к общему

Теория понимания программ от частного к общему предполагает, что программисты сначала читают код и затем мысленно группируют утверждения в коде в абстракции более высокого уровня. Эти абстракции в дальнейшем также группируются, и этот процесс повторяется пока не достигается высоко-уровневое понимание программы.

### Оппортунистическая и систематические стратегии

При использовании этих стратегий программисты либо систематически читают код в деталях, отслеживая потоки управления и данных в программе, для получения целостного понимания программы, либо читают его по необходимости, фокусируясь только на коде, относящемся к текущей задаче. В первом случае, программисты получают как статическое знание о программе (информацию о ее структуре), так и знание о причинно-следственных связях в ней (знание о взаимодействии между компонентами при их выполнении). Это позволяет им сформировать ментальную модель программы. При оппортунистическом подходе программисты в основном получают статическое знание, приводящее в результате к формированию более слабой ментальной модели работа программы. Это приводит к большему числу ошибок, так как программисты не могут распознать причинно-следственные связи между компонентами внутри программы.

### Стратегии чтения программного кода

На рисунке ниже представлены траектории движения глаз двух программистов-экспертов при чтении одного и того же кодах[^12]:

<img src="code_reading_patterns.png" width="90%"/>

Перед этими программистами были поставлены разные задачи: так, от первого (рис. слева) ожидали получить ответ, чему равно `rect2.area()`, второго предупредили, что ему будет задан вопрос относительно алгоритма с возможностью выбрать ответ из списка возможных. 

Как мы можем видеть эти траектории достаточно сильно различаются, что связано, по-видимому, не только с разными задачами, поставленными перед ними, но и их индивидуальными особенностями.

Авторы эксперимента описывают манеру чтения кода первым испытуемым как совершенно непредсказуемую, когда он перескакивал с одного места на другое, практически нигде не задерживаясь на сколько либо продолжительное время.

Второй же испытуемый, по словам экпериментаторов, читал код медленно и методически.

Действительно на иллюстрации слева мы наблюдаем достаточно хаотическую траекторию с большим количеством вертикальных саккад, а на правой – преимущественногоризонтальные саккады, большинство из которых можно связать с чтением текста так такового.

Авторы описывают следующие базовые типы движений глаз, составляющие более сложные стратегии чтения кода:

| Тип                   | Описание                                                     |
| --------------------- | ------------------------------------------------------------ |
| Flicking              | Взгляд перемещается вперед и назад между двумя соотносящимися элементами, такими как списки формальных и актуальных параметров метода. |
| JumpControl           | Взгляд переходит на следующую строку, следуя за потоком выполнения. |
| JustPassingThrough    | Фиксации на свободном месте в процессе перехода куда-то еще. |
| LinearHorizontal      | Целая линия последовательно и равномерно читается целиком слева направо или справо налево. |
| LinearVertical        | Техт читается строка за строкой, как минимум, для трех строк, независимо от потока выполнения программы, не различая сигнатуру и тело функции. |
| RetraceDeclaration    | Частые, повторяющиеся скачки между местами использования и определения переменных. Вид Flicking. |
| RetraceReference      | Частые, повторяющиеся скачки между местами использования переменных. Вид Flicking. |
| Scan                  | Первичное поверхностное чтение всех строк кода сверху-вниз. Подготовительное чтение всей программы, которое занимает 30% времени на ее обзор (review). |
| Signatures            | Все сигнатуры функций просматриваются, перед тем как начать изучение тела метода/конструктора. |
| Thrashing             | Взгляд перемещается быстро и неконтролируемо в последовательности, которая кажется не имеет какого-то определенного смысла. |
| Word(Pattern)Matching | Простое сопоставление визуальных шаблонов.                   |



<!-- | Стратегия                   | Описание                                                     | -->
<!-- | --------------------------- | ------------------------------------------------------------ | -->
<!-- | AttentionToDetail           | Readers are trying to comprehend a piece of code that is not believed to contain bugs. In most cases, there is a slowness to AttentionToDetail, but the subject could also be verifying a global property, such as that argument/ parameter types agree or that the semicolons are present in the right places. | -->
<!-- | DataFlow                    | Following a single object in memory as its value changes through the program. Can also occur backwards through control flow in service of debugging and/or program execution comprehension. | -->
<!-- | Debugging                   | Similar to DesignAtOnce, but more equally distributed fixation durations, and more equally distributed time of fixation for all text elements. Based on pattern LinearHorizontal and LinearVertical. The subject's intention is to find syntactical or semantic errors. Very small jumps, where the subject is presumably validating the syntax. (Note | -->
<!-- | Deductive                   | From general to special, from definition to use, typically includes LinearHorizontal. | -->
<!-- | DesignAtOnce                | LinearHorizontal or Scan, hardly any jumps back. The subject's intention is to understand the general or algorithmic idea, without having the need to go into details. Aiming at understanding by linear reading of the complete (needed) code. Can easily be confused with excessive demand/trial and error, might also include TestHypothesis on local levels. Captures high-level algorithmic thinking, thus features rather large steps as the gaze sweeps over the text typically associated with Linear and Scan patterns. Suggests reading through part or all of the code in a linear manner, intending to acquire an overall understanding of it. | -->
<!-- | FlowCycle                   | The same program flow sequence is followed several times, the intent might be to gain a first understanding of the flow, strengthening and reinforcing it with repeated examinations of the same code. The Flicking pattern might then suggest the simplest level of the FlowCycle strategy. | -->
<!-- | Inductive                   | From the special to general, from context to definition, typically combined strategy (mix of Scan, JumpControl and LinearHorizontal). | -->
<!-- | InterproceduralControl-Flow | The subject follows call-chains in real or simulated sequence of control flow. Intention is to understand the execution or to get the outcome of a code section. Focus is on execution between blocks. | -->
<!-- | IntraproceduralControl-Flow | The subject scans lines of code in real or simulated program execution order. Intention is to understand the execution or to get the outcome of a code section. Focus is on execution on block level. | -->
<!-- | StrayGlance                 | A glance where something is looked at that does not necessarily involve comprehension or something that we cannot explain. | -->
<!-- | TestHypothesis              | Repetition of a pattern or gaze path. Occurs in connection with DesignAtOnce or ControlFlow. The subject's intention is to check for some details in understanding. Hints at some issue where either the person was distracted, or which is more difficult to comprehend. Involves repetition of a pattern of gaze, and suggests further concentration in order to better understand a particular detail. | -->
<!-- | Touchstone                  | Analogue to checking the risk of any deal. Before transporting some goods through an unknown route, first you go there without merchandise and see, where to turn and where the traffic lights are. And when you are sure about everything, you take the goods with you to finish the deal. Comparing this example with program comprehension, the route is the algorithm, while the goods are the parameters. | -->
<!-- | Trial&Error                 | Similar to DesignAtOnce, but with higher reading speed, and some irregular jumps and repetitions in reading. The subject's intention is to cope with cognitive overload and to try to find some place to start the understanding process. Connected to JustPassingThrough and Wandering. | -->
<!-- | Wandering                   | It appears that the subject was backtracking, seemingly searching for a point to resume the reading after a particular path of reasoning had been exhausted, essentially a transition period or a brief rest between bursts of effort. | -->



### Роль идентификаторов[^4]

Идентификаторы в коде программы часто выполняют роль маяков для планов программирования, поддерживающих ментальные модели более высокого уровня. Идентификаторы составляют примерно 70% исходного кода.

В общем случае, использование целых слов в идентификаторах приводит к лучшему восприятию программы, чем при использовании сокращений.

Идентификаторы, которые нарушают некоторые правила, приводят к более низкому качеству кода (больше ошибок).

Использование более длинных имен снижает правильность и требует больше времени для запоминания.

При сравнении эффективности использования идентификаторов, использующих camelCase нотацию и нотацию с подчеркиванием, в задаче поиска было показано, что хотя вид использованной нотации не влияет на аккуратность результата, использование идентификаторов с подчеркиванием требует меньше времени и усилий для достижения того же результата.

При исследовании влияния разных видов заполнений промежутков между словами на время чтения было обнаружено, что скорость уменьшалась на 10-75% в зависимости от вида заполнителя.


## Обобщение результатов

### Визуальное представление

Говоря о визуальном восприятии программы, мы должны помнить, что первое впечатление, оценка визуальной структуры программы происходит главным образом за счет амбьентного зрения, обладающим малой остротой и цветовосприятием, ухудшающимися от центра к краю. Амбьентное зрение помогает нам выделить точки интереса в коде, для его дальнейшего анализа и чтения с помощью фокального зрения. Поэтому, когда мы форматируем текст программы  для того, чтобы наилучшим образом отобразить в нем его логическую структуру, мы апеллируем именно к амьбентому зрению.

<!--Визуальное представление программы, это то, что изначально видит читатель, до того, как погрузится в глубину ее текста. Это то, с чем он имеет дело, когда выныривает из его глубин, для того, чтобы окинуть взглядом ее общую структуру и понять, куда двигаться дальше. Если то, что он видит слабо соответствует структуре программы, то ему не остается ничего другого, как двигаться наугад, малыми саккадами, тщательно вчитываясь в каждое выражение.-->

Как формируется это представление?

Во время создания программы мы располагаем различные элементы ее текста определенным образом – выравнивая их, располагая ближе или дальше относительно друг друга, – тем самым формируя из них области изображения, воспринимаемые как единое целое. Наша задача при этом заключается в том, чтобы эти объекты соотносились с элементами логической структуры программы.
<!-- В идеальном случае, в программе должно быть возможным легко выделить области, относящиеся к синтаксически или семантически связанным элементам. -->

Например, в определении функции нам необходимо визуально разделить объявление функции, включающее её имя, возвращаемый тип, список параметров, и тело функции. Внутри тела функции необходимо разделить код инициализации начальных переменных, тело основного алгоритма, формирование и возвращение результата. В свою очередь, внутри кода инициализации нам надо разделить область типов, имен переменных и присваиваемых им значений.

Таким образом, мы разделяем области кода как по вертикали, так и по горизонтали. В первом мы случае выполняем эти разделения посредством добавления пустых строк. Во втором – мы используем отступы и выравнивание.

Отступы служат для формирования визуального представления иерархии в логической структуре программы между блоками кода, находящимися на разных строках.

Рассмотрим следующий пример кода, найденного на просторах Интернета:

<img src="indent1.png"/>

Список аргументов представлен в виде колонки и имеет отступ относительно первой строки. Достаточно ли этого отступа для того, чтобы правильно отобразить логическую структуру программы?

Очевидно, что нет. Правило сходства по близости связывает список аргументов с именем переменной сильнее, чем с именем функции даже несмотря на то, что благодаря подсветке синтаксиса формируется сходство по цвету. Но что случится, если алгоритм подсветки изменится? Вот как выглядел этот же код на gitlab:

<img src="indent3.png"/>

В данном случае подсветка синтаксиса еще больше ухудшила ситуацию, поскольку правило сходства по цвету теперь также усиливает связь аргументов с именем переменной.

(Это яркий пример, показывающий, что, несмотря на то, что подсветка синтаксиса облегчает восприятие кода при его написании, нельзя принимать ее во внимание для оценки того, насколько  удобочитаемым и правильно отражающим структуру программы является его конкретное визуальное представление.)

Чтобы правильно отобразить логическую структуру этого кода в его визуальное представление, необходимо, чтобы список аргументов имел отступ не относительно начала строки, а относительно начала имени функции:

<img src="indent4.png"/>

Имеет смысл провести тест, аналогичный популярному у разработчиков пользовательского интерфейса "тесту с прищуриванием" (_squint test_), смысл которого заключается в том, чтобы попробовать сформировать расфокусированное изображение разработанного интерфейса (текста программы в нашем случае), и оценить общее какое общее представление получает о нем пользователь в самый первый момент времени. Мы отключим подсветку синтаксиса для того, чтобы исключить группировку по фактору сходства по окраски, которую мы не контролируем:

<img src="indent4_blurred.png"/>

Видно, что имя функции и список аргументов формируют сильно связанную область. Однако при использовании двух пробелов для отступа подчиненость списка аргументов относительно имени функции выглядит недостаточно выразительно. Использование четырех пробелов помогает решить эту проблему: <img src="indent4-4_blurred.png"/>

Остается еще одна проблема: список аргументов выглядит как одно неструктурированное пятно, немотря на то, что в нем присутствуют два типа элементов – метки аргументов и их значения, то есть этот список обладает определенной структурой. Для того, чтобы визуально выделить эту структуру, мы используем выравнивание.

В общем случае, выравнивание схожих элементов в последовательности однородных строк значительно облегчает чтение и поиск. Фактически, в этом случае мы используем табличную форму представления информации. При этом в некоторых случаях имеет смысл выравнивать не по левому, а по правому краю. Например, при представлении блока строк в табличной форме, содержащих однотипные структурированные списки идентификаторов, в котором некоторые идентификаторы оканчиваются одним и тем же словом на всех строках. Или при выравнивании пар ключевое слово/значение в таких языках как С#, Objective-C, Swift.

Рассмотрим различные способы форматирования списка аргументов в виде метка:значение.

###### Однострочное форматирование {#l1}

```
try coordinator.replacePersistentStore (at: tempStoreUrl, destinationOptions: dstOptions, withPersistentStoreFrom: storeUrl, sourceOptions: srcOptions, ofType: store.type)
```

Недостатки: очень плохо прослеживается структура выражения, поиск идентификатороы затруднен. Этот вариант предназначен лишь для того, чтобы его тщательно читали. Он не использует особенности амбьентного зрения человека для распознания логической структуры программы.

###### Выравнивание пар ключ:значение

```
try coordinator.replacePersistentStore (at: tempStoreUrl,
                                        destinationOptions: dstOptions,
                                        withPersistentStoreFrom: storeUrl,
                                        sourceOptions: srcOptions,
                                        ofType: store.type)
```

Этот вариант выглядит лучше в том смысле, что в нем спецификация имени метода и список аргументов явно отделены друг от друга. Проще поиск в списке аргументов, поскольку каждая пара в нем располагается на отдельной строке и ключи(метки) выравнены по левому краю.

Тем не менее различение меток и значений затруднено, поскольку отсутствует явная граница между областями меток и значений для всего списка. Кроме того, этот код вызывает некоторый дискомфорт из-за несимметричного восприятия текста по горизонтали. Поскольку текст воспринимается как зафиксированный слева и свободный справа, в визуальном представлении этот код выглядит как большой груз (область списка аргументов), подвешенный на тонком и длинном рычаге. Основная масса кода оказывается смещена в правую, менее важную часть пространства.

Можно попробовать исправить последний недостаток сместив список аргументов влево:

```
try coordinator.replacePersistentStore (
                    at: tempStoreUrl,
                    destinationOptions: dstOptions,
                    withPersistentStoreFrom: storeUrl,
                    sourceOptions: srcOptions,
                    ofType: store.type)
```

Для лучшего представления внутренней структуры списка аргументов необходимо сформировать явную разделительную линию между областями меток и значений. Здесь у нас есть два варианта.

###### Вариант 1: метки и аргументы выравнены влево по отдельности

```
try coordinator.replacePersistentStore (
                    at:                      tempStoreUrl,
                    destinationOptions:      dstOptions,
                    withPersistentStoreFrom: storeUrl,
                    sourceOptions:           srcOptions,
                    ofType:                  store.type)
```

Из всех предложенных до сих пор вариантов, этот наиболее точно передает логическую структуру кода. В нем явно различимы области меток и значений, идентификация и поиск отдельных элементов внутри их значительно облегчается. Однако из-за большой разницы в длинах меток аргументов связи внутри пар с короткими метками оказываются ослабленными.

###### Вариант 2: внутреннее выравнивание

```
try coordinator.replacePersistentStore (at: tempStoreUrl,
                        destinationOptions: dstOptions,
                   withPersistentStoreFrom: storeUrl,
                             sourceOptions: srcOptions,
                                    ofType: store.type)
```

Обладая всеми преимуществами варианта 1, этот вариант для даннного примера выглядит более естественным. В отличие от всех предыдущих вариантов, в нем метки аргументов выглядят как естественное продолжение имени метода, как это и должно быть в данном случае. Код выглядит достаточно компактным и без необходимости переноса списка аргументов на следующую строку.

Для предыдущего примера код в этом варианте оформления будет выглядеть следующим образом:

```
let success = reticulateSplines (spline: splines,
                       adjustmentFactor: 1.3,
                      translateConstant: 2,
                                comment: "normalize the display")
```

Однако существуют случаи, как на примере ниже, когда ничего уже поправить нельзя и остается только смириться:

```
func tableView(_ tableView: UITableView,
               titleForHeaderInSection section: Int) -> String?
```



В некоторых случаях, не обязательно формировать вертикальную линию разделения между областями кода для их визуального различения. Достаточно просто обеспечить монотонность изменения этой линии, просто изменив порядок строк и/или разделив области кода, в которых такая монотонность нарушается.

Например:

```
_closeCallback = closeCallback;
_shouldCloseCallback = shouldCloseCallback;
_resetPasswordCallback = resetPasswordCallback;
_trySilentLoginCallback = trySilentLoginCallback;
_mapSpecialSyncpointsCallback = mapSpecialSyncpointsCallback;
_mapCustomSyncpointsCallback = mapCustomSyncpointsCallback;
_validatePathCallback = validatePathCallback;
_changeLocationCallback = changeValidationCallback;
_defaultRegistrationMode = defaultRegistrationMode;
_logWarnCallback = logWarnCallback;
```

можно просто переупорядочить как

```
_closeCallback = closeCallback;
_logWarnCallback = logWarnCallback;

_shouldCloseCallback = shouldCloseCallback;
_validatePathCallback = validatePathCallback;
_resetPasswordCallback = resetPasswordCallback;
_changeLocationCallback = changeValidationCallback;
_trySilentLoginCallback = trySilentLoginCallback;
_defaultRegistrationMode = defaultRegistrationMode;

_mapCustomSyncpointsCallback = mapCustomSyncpointsCallback;
_mapSpecialSyncpointsCallback = mapSpecialSyncpointsCallback;

```



Как упоминалось выше, существует некоторая ассиметрия в том, как человек воспринимает левую и правую части визуальной сцены. Эта ассиметрия еще более естественным образом пристутствует в восприятии текста программы: текст жестко привязан к левому краю, где отступы задают уровень иерархии в логической структуре программы. Правый же край свободен и не имеет жесткого ограничения. Чтение слева направо и сверху вниз определяет то, что начало чего-либо (место, где появляется что-то новое) мы ожидаем увидеть сверху и слева или по центру.

В этом смысле нельзя назвать удачными с точки зрения читаемости конструкции вида:

```
let task = urlSession.dataTask(with: request) { data, response, error in
    guard let response = response as? HTTPURLResponse else {
        ...
    }
    ...
}
```

В таких конструкциях новое пространство имен начинается в конце строки, то есть в области наименьшей важности, там где это начало не ожидаемо. Более естественно расположить начало этого блока кода там, где он и должен быть:

```
let task = urlSession.dataTask(with: request)
{
    data, response, error in
    guard let response = response as? HTTPURLResponse else {
        ...
    }
    ...
}
```

Отсутствие жесткого ограничения справа, тем не менее, не озачает, что ограничения нет. Многовековой опыт книгопечатания,[^13] и десятилетия опыта, наработанного [веб-дизайнерами](http://webtypography.net/2.1.2), сходятся к тому, что оптимальная длина строки, обеспечивающей комфортное чтение составляет приблизительно 45-75 символов.

Несмотря на структурные отличия текста программы, трудно вообразить, что эти отличия настолько сильны, что могут сделать длинные строки, трудные для чтения обычных текстов, легкими в случае, когда мы читаем программу. Также как и при чтении прозы, длинные строки затрудняют переход от конца текущей строки к началу следующей. Но что еще хуже, длинные строки скрывают стуруктуру программы, а также увеличивают _эксцентриситет_  при визуальном поиске.

Структура программы теряется, например, в случае однострочного форматирования на [листинге](#l1) выше, где метки аргументов и аргументы оказываются перепутанными, и чтобы найти определенный аргумент или метку, приходится прочитывать строку. Такое расположение аргументов, однако, оказывается допустимым в случае короткой строки, когда весь список аргументов легко охватывается одним взглядом.

По ряду объективных факторов нам не удается полностью избежать длинных строк (например, из-за использования длинных идентификаторов, которые мы не в силах изменить). Также в случаях, когда нас не интересует структура выражения (например, при выводе отладочного сообщения в лог программы), использование длинной строки может оказаться даже предпочтительнее структурирования длинного выражения разбивкой его на несколько строк.

В общем случае, длинная строка, как и длинный идентификтаор, это признак плохой читаемости кода.

### Имена

Имена играют важнейшую роль для обеспечения удобочитаемости программного кода. Они занимают его большую часть и часто играют роль маяков, позволяющих идентифицировать характерные структурные части программы. Основные требования к именам – это их краткость и выразительность. Чем имя длиннее, тем оно труднее для чтения, запоминания и поиска. Длинные имена, как правило приводят к длинным строкам, что тоже затрудняет чтение и поиск. Требование выразительности означает, что в области контекста использования, идентификатор должен позволять однозначно определять роль обозначаемого им элемента программы.

<!-- «Когда форма проще своего содержания, то заключенная в ней информация не достигает своей цели». -->

Требования краткости и выразительности могут очевидным образом конфликтовать друг с другом, поскольку выразительность может требовать использования более длинных, составных имен. Поэтому имеет смысл сделать оценку допустимой рекомендованной длины идентификатора. В качестве такой оценки можно использовать длину в 14 символов, как максимальную длину коротких идентификаторов. Это число немного больше средней области распознавания, но меньше области восприятия текста, и мы рассчитываем на то, что распознавание такого слова не потребует более 1-2 фиксаций. Следующий приемлимый порог – это длина порядка 22 символов (предыдущая длина плюс 8 символов для дополнительной саккады). При этом мы рассчитываем, что для распознавания этого имени не потребуется более 2-3 фиксаций. 

Эти рекомендации достаточно хорошо согласуются с теми, которые приводит в своей книге[^14] Стив Макконнелл: 10-16 и 8-20. Теперь мы знаем почему это так.  

На практике иногда приходится использовать имена, длины которых выходят за предлагаемые пределы. Например, когда имя включают в себя некоторое стандартное именование группы, к которой относится данный элемент, как в `PreferencesViewController`. В этом случае лучше значимую, уникальную часть имени располагать в начале слова. При этом мы рассчитываем, что мы сможем распознать уникальную часть имени уже при первой фиксации, и в то же время нам не потребуется больших усилий для распознания «стандартного дополнения».

За редким исключением не имеет смысла использовать в именах какие-либо префиксы, описывающие некоторые общие характеристики (например тип) или для различения классов,  являющихся частью вашего приложения. Префиксы маскируют смысловую часть имени, в их присутствии позиция первой фиксации на слове при чтении сдвигается  влево от оптимальной, они требуют определенных усилий на дополнительный анализ слова. В некоторых случаях они могут изменять значение имени (`kBytesPerSec` это "килобайты в секунду" или константа `BytesPerSec`?). 

Декорирование имен классов и функций имеет смысл лишь в случае разработки библиотеки на языке в котором отсутсвует понятие пространства имен, позволяющих ограничить их видимость. Все сущности, определяемые внутри вашего приложения находятся на верхнем уровне пространства имен и, как правило, не нуждаются в каких-либо префиксах  для предотвращения конфликта имен.

Всегда декорируйте обращения к членам класса внутри его методов. Это обязательно, если имя параметра метода совпадает с именем члена класса. Но это стоит делать всегда, потому что тот, кто будет читать ваш код потратит немного меньше усилий на то, чтобы понять является ли данная переменная или  функция членом класса, и избавит его от необходимости искать место ее объявления. 

Также всегда декорируйте статические и глобальные переменные. Такие переменные редки и обладают специфическим поведением или несут в себе потенциальную опасность, а это всегда стоит отметить. Например, в языке С для этого обычно используют префиксы `s_`  и `g_`. Я рекомендую `_s_` и `_g_`, чтобы избавить себя от необходимости анализа того, что этот префикс не несет никакой иной смысловой нагрузки. 

<!--В общем случае, каждый случай использования длинных идентификаторов (> 12-14 символов) должен рассматриваться как вынужденный компромисс, который в общем случае ведет к ухудшению читаемости кода.-->

### Пробелы

Как показали результаты исследований, использование любого другого разделителя между словами требует больших усилий при чтении. Это связано с затруднением при определении границ слова, и вызванным этим трудностями его распознавания и планировании следующей саккады. 

Пробелы также участвуют в формировании визуальной структуры программы для разделения различных элементов ее логической структуры. Поэтому, например, имеет смысл разделять пробелом имя функции и список ее параметров/аргументов:

```
// При отсутствии пробела первый аргумент сливается с именем функции,
// что затрудняет чтение. Кроме того, нарушается визуальная структура:
// первый аргумент связан с этим именем сильнее, чем со вторым аргументом
// в списке аргументов.

result = someFunction(firstArgument, secondArgument);
result = someFunction (firstArgument, secondArgument);
```

В случае, когда совокупная длина идентификаторов не превышает размера области распознавания, это требование настолько критическим:

```
strcat(dest, src)
strcat (dest, src)
```

### Расстановка фигурных скобок.

На сегодняшний день в языках с Си-подобным синтаксисом существуют два основных способа расстановки фигурных скобок: _One Truce Brace Style_ (_1TBS_) и _Allman_. Остальные [известные варианты](https://en.wikipedia.org/wiki/Indentation_style) либо являются их вариациями, либо выглядят достаточно экзотически и, соответвенно, популярностью не пользуются.

В _1TBS_ открывающая фигурная скобка располагается в конце строки, содержащей окончание соответствующего синтаксического элемента, с которым она связана. В стиле _Allman_, эта скобка располагается на следующей линии с тем же отступом, как и начало связанного элемента.

В общем случае стиль _Allman_ предпочтительнее, поскольку в нем открывающая и закрывающая скобки выровнены по вертикали. Это значительно облегчает поиск, например, парной открывающей скобки, поскольку требует лишь вертикального перемещения глаз. При этом на пути следования взгляда от одной скобки к другой, как правило, нет никакого текста, и поиск фактически происходит до первого символа. В _1TBS_ поиск осуществляется в широком секторе, причем взгляд проходит через текст, который надо анализировать, и который часто содержит вложенные пары фигурных скобок, что также может затруднять обнаружение нужной нам пары.

Кроме того, поскольку в стиле _Allman_ скобки располагаются на отдельных строках, блок кода внутри них визуально явно отделен от заголовка конструкции, что лучше сответствует структуре этой конструкции. В _1TBS_ такого явного разделения нет, особенно в случае, когда предшествующая часть занимает несколько строк.

Открывающая фигурная скобка является частью блока кода, который она обрамляет на пару с закрывающей скобкой; и, поскольку мы ожидаем увидеть начала нового блока слева, то естественно и открывающую скобку как символ начала нового блока, располагать слева, в начале новой строки.

Тем не менее, есть случаи, когда 1TBS может оказаться предпочтительнее, чем Allman. Например, в случае короткого условия в операторе `if`, когда код внутри скобок содержит 1-3 строки. В такой ситуации использование стиля Allman может приводить к развалу визуальной структуры кода, так что заголовок конструкции, оказывается недостаточно связанным с кодом внутри скобок по сравнению с окружающими элементами. В общем случае, можно предложить следующую эвристику: использование 1TBS стиля возможно, когда заголовок утверждения, предшествующий `{` занимает одну строку, а сама скобка расположена слева или в центральной области обрамляемого блока кода, и этот код не содержит более трех строк.

Таким образом, несмотря на то, что стиль Allman в целом выглядит предпочтительнее, выбор того или иного способа расстановки должен осуществляться программистом в каждом конкретном случае, для того чтобы сформировать оптимальное визуальное представление соответствующей части программного кода. Можно предложить следующий алгоритм действий: по умолчанию использовать стиль _Allman_, но быть готовым к тому, что в каком-то случае может потребоваться изменить его на _1TBS_, если получившийся код не достаточно ясно отражает структуру программы.

<!-- 6. Использование символов табуляции. -->
<!-- Единственная причина использования символов табуляции – это "оптимизация" процедуры редактирования. -->
<!-- Вместе с тем, они добавляют в текст программы скрытую структуру, которая часто приводит к разрушению визуального преставления кода при переносе из одного окружения в другое. Например, вы можете быть счастливы установив ширину символа табуляции в четыре пробела на своем компьютере, но на github ваш код скорее всего будет иметь некорректные отступы. Его визуальная структура будет нарушена.  -->


<!-- В Rust Book пишут просто и без затей: "Хорошим стилем является размещение открывающей скобки в строке объявления функции, оставляя пробел между ними" ("It’s good style to place the opening curly bracket on the same line as the function declaration, adding one space in between"). -->

## Резюме

<!--Иван Бортко писал[^7]: *«Пролог-программы иной раз напоминают стихи по эстетической привлекательности своих идей и формы».* Это утверждение выглядит несколько странно, если вспомнить, как обычно выглядят стихи. Но если говорить о ритмичности и мелодичности, присущей стихам, то становится понятно, о чем, возможно, писал автор книги о языке Пролог.-->

<!--В идеале, «красивые» и хорошо продуманные технические решение должны выглядить привлекательно будучи оформленными в виде текста программы.-->
<!--Конечно, на практике эстетика кода бывает сильно ограниченна внешними факторами, такими, например, как синтаксис языка.-->

<!-- Визуальное представление программы выразительно подчеркивает структуру программы, а  -->
<!-- Если логическая структура программы обладает такими свойствами, а стиль оформления программы выразительно подчеркивает эту структуры, то очевидно, что визуальная структура должна также обладать этими свойствами. -->

<!-- Эстетическая составляющая служит мерой качества. -->



<!-- Подводя итоги, можно сказать, что основными критериями выбора правил оформления программного кода должно быть повышение удобочитаемости текста программы и формирование ее визуального представления таким образом, чтобы оно максимально возможным образом отражало синтактическую и семантическую структуру программы.  -->
<!-- При этом удобочитаемость программы улучшается при разделении идентификаторов пробелами, и, как правило, ухудшается при увеличении их длины.  -->

<!-- Структурирование текста программы связано с формированием двумерной визуальной структуры, в которой синтаксически и семантически связанные элементы программы образуют геометрически сбалансированные области. Иными словами мы отражаем структуру программу в некоторое изображение. Для оценки качества этого представления можно попытаться оценить его отодвинувшись от экрана и разфокусировав взгляд.  -->



--
[^1]: [Eye Movements in Reading and Information Processing: 20 Years of Research. Keith Rayner – University of Massachusetts at Amherst](https://www.semanticscholar.org/paper/Eye-movements-in-reading-and-information-20-years-Rayner/87c8a7be8d5e2e2209e766c3e28a3e8ee5babb64)
[^2]: [Eye Movements in Code Reading: Relaxing the Linear Order. Roman Bednarik, Bonita Sharif](https://dl.acm.org/doi/10.5555/2820282.2820320)
[^3]: [Theories, tools and research methods in program comprehension: Past, Present and Future. Margaret-Anne Storey](http://www.ptidej.net/courses/inf6306/fall10/slides/course8/Storey06-TheoriesMethodsToolsProgramComprehension.pdf)
[^4]: [An Eye Tracking Study on camelCase and under_score Identifier Styles. Bonita Sharif and Jonathan I. Maletic – Department of Computer Science Kent State University](http://www.cs.kent.edu/~jmaletic/papers/ICPC2010-CamelCaseUnderScoreClouds.pdf)
[^5]: [Achieving Software Quality through Source Code Readability, Phillip Relf](https://www.researchgate.net/publication/238443707_Achieving_Software_Quality_through_Source_Code_Readability)
[^6]: [Relating Identifier Naming Flaws and Code Quality: An Empirical Study. Simon Butler](https://ieeexplore.ieee.org/document/5328661)
[^7]: Грегори Р.Л. Глаз и Мозг. М.:Прогресс, 1970
[^8]: Дэвид Хантер Хьюбел. Глаз, мозг, зрение. Мир, 1970
[^9]: Величковский Б.М. Когнитивная наука. Основы психологии познания. Academia, Смысл, 2006
[^10]: Рудольф Арнхейм. Искусство и визуальное восприятие. М.:Архитектура-С, 2012
[^11]: Ярбус А.Я. Роль глаз в процессе зрения. М.:Наука, 1965
[^12]: [Eye movements in programming education: analysing the expert’s gaze. Simon. University of Newcastle, Australia](http://emipws.org/wp-content/uploads/2015/02/emip2013_report.pdf)
[^13]: Роберт Брингхерст. Основы стиля в типографике. М.:Дмитрий Аронов, 2006
[^14]: Макконнелл С. Совершенный код. М.:Русская редакция, 2010

